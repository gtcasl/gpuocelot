<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MC-GPU_kernel_v1.1.cu Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>MC-GPU_kernel_v1.1.cu</h1><a href="MC-GPU__kernel__v1_81_8cu.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment"></span>
<a name="l00002"></a>00002 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00003"></a>00003 <span class="comment"></span><span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">//              ****************************</span>
<a name="l00005"></a>00005 <span class="comment">//              *** MC-GPU , version 1.1 ***</span>
<a name="l00006"></a>00006 <span class="comment">//              ****************************</span>
<a name="l00007"></a>00007 <span class="comment">//                                          </span><span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">//!  Definition of the CUDA GPU kernel for the simulation of x ray tracks in a voxelized geometry.</span>
<a name="l00009"></a>00009 <span class="comment">//!  This kernel has been optimized to yield a good performance in the GPU but can still be</span>
<a name="l00010"></a>00010 <span class="comment">//!  compiled in the CPU without problems. All the CUDA especific commands are enclosed in</span>
<a name="l00011"></a>00011 <span class="comment">//!  pre-processor directives that are skipped if the parameter "USING_CUDA" is not defined</span>
<a name="l00012"></a>00012 <span class="comment">//!  at compilation time.</span>
<a name="l00013"></a>00013 <span class="comment"></span><span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">//        ** DISCLAIMER **</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment">// This software and documentation (the "Software") were developed at the Food and</span>
<a name="l00017"></a>00017 <span class="comment">// Drug Administration (FDA) by employees of the Federal Government in the course</span>
<a name="l00018"></a>00018 <span class="comment">// of their official duties. Pursuant to Title 17, Section 105 of the United States</span>
<a name="l00019"></a>00019 <span class="comment">// Code, this work is not subject to copyright protection and is in the public</span>
<a name="l00020"></a>00020 <span class="comment">// domain. Permission is hereby granted, free of charge, to any person obtaining a</span>
<a name="l00021"></a>00021 <span class="comment">// copy of the Software, to deal in the Software without restriction, including</span>
<a name="l00022"></a>00022 <span class="comment">// without limitation the rights to use, copy, modify, merge, publish, distribute,</span>
<a name="l00023"></a>00023 <span class="comment">// sublicense, or sell copies of the Software or derivatives, and to permit persons</span>
<a name="l00024"></a>00024 <span class="comment">// to whom the Software is furnished to do so. FDA assumes no responsibility</span>
<a name="l00025"></a>00025 <span class="comment">// whatsoever for use by other parties of the Software, its source code,</span>
<a name="l00026"></a>00026 <span class="comment">// documentation or compiled executables, and makes no guarantees, expressed or</span>
<a name="l00027"></a>00027 <span class="comment">// implied, about its quality, reliability, or any other characteristic. Further,</span>
<a name="l00028"></a>00028 <span class="comment">// use of this code in no way implies endorsement by the FDA or confers any</span>
<a name="l00029"></a>00029 <span class="comment">// advantage in regulatory decisions.  Although this software can be redistributed</span>
<a name="l00030"></a>00030 <span class="comment">// and/or modified freely, we ask that any derivative works bear some notice that</span>
<a name="l00031"></a>00031 <span class="comment">// they are derived from it, and any modified versions bear some notice that they</span>
<a name="l00032"></a>00032 <span class="comment">// have been modified.</span>
<a name="l00033"></a>00033 <span class="comment">//                                                                            </span>
<a name="l00034"></a>00034 <span class="comment">//</span><span class="comment"></span>
<a name="l00035"></a>00035 <span class="comment">//!                     @file    MC-GPU_kernel_v1.1.cu</span>
<a name="l00036"></a>00036 <span class="comment">//!                     @author  Andreu Badal (Andreu.Badal-Soler@fda.hhs.gov)</span>
<a name="l00037"></a>00037 <span class="comment">//!                     @date    2010/05/14</span>
<a name="l00038"></a>00038 <span class="comment"></span><span class="comment">//                       -- Original code started on:  2009/04/14</span>
<a name="l00039"></a>00039 <span class="comment">//</span><span class="comment"></span>
<a name="l00040"></a>00040 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00041"></a>00041 <span class="comment"></span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="comment"></span>
<a name="l00044"></a>00044 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00045"></a>00045 <span class="comment">//!  Initialize the image array, ie, set all pixels to zero</span>
<a name="l00046"></a>00046 <span class="comment">//!  Essentially, this function has the same effect as the command: </span>
<a name="l00047"></a>00047 <span class="comment">//!   "cutilSafeCall(cudaMemcpy(image_device, image, image_bytes, cudaMemcpyHostToDevice))";</span>
<a name="l00048"></a>00048 <span class="comment">//!  </span>
<a name="l00049"></a>00049 <span class="comment">//!  CUDA performs some initialization work the first time a GPU kernel is called.</span>
<a name="l00050"></a>00050 <span class="comment">//!  Therefore, calling a short kernel before the real particle tracking is performed</span>
<a name="l00051"></a>00051 <span class="comment">//!  may improve the accuracy of the timing measurements in the relevant kernel.</span>
<a name="l00052"></a>00052 <span class="comment">//!  </span>
<a name="l00053"></a>00053 <span class="comment">//!       @param[in,out] image   Pointer to the image array.</span>
<a name="l00054"></a>00054 <span class="comment">//!       @param[in] pixels_per_image  Number of pixels in the image (ie, elements in the array).</span>
<a name="l00055"></a>00055 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00056"></a>00056 <span class="comment"></span><span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span>__global__
<a name="l00058"></a>00058 <span class="preprocessor">#endif</span>
<a name="l00059"></a><a class="code" href="MC-GPU__kernel__v1_81_8cu.html#0ea66eae6d288c9e4d2456ee1033429f">00059</a> <span class="preprocessor"></span><span class="keywordtype">void</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#0ea66eae6d288c9e4d2456ee1033429f" title="Initialize the image array, ie, set all pixels to zero Essentially, this function...">init_image_array_GPU</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>* image, <span class="keywordtype">int</span> pixels_per_image)
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061   <span class="keywordtype">int</span> my_pixel = threadIdx.x + blockIdx.x*blockDim.x;
<a name="l00062"></a>00062   <span class="keywordflow">if</span> (my_pixel &lt; pixels_per_image)
<a name="l00063"></a>00063   {
<a name="l00064"></a>00064     <span class="comment">// -- Set the current pixel to 0 and return, avoiding overflow</span>
<a name="l00065"></a>00065     image[my_pixel] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);    <span class="comment">// Initialize non-scatter image</span>
<a name="l00066"></a>00066     my_pixel += pixels_per_image;                     <span class="comment">//  (advance to next image)</span>
<a name="l00067"></a>00067     image[my_pixel] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);    <span class="comment">// Initialize Compton image</span>
<a name="l00068"></a>00068     my_pixel += pixels_per_image;                     <span class="comment">//  (advance to next image)</span>
<a name="l00069"></a>00069     image[my_pixel] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);    <span class="comment">// Initialize Rayleigh image</span>
<a name="l00070"></a>00070     my_pixel += pixels_per_image;                     <span class="comment">//  (advance to next image)</span>
<a name="l00071"></a>00071     image[my_pixel] = (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(0);    <span class="comment">// Initialize multi-scatter image</span>
<a name="l00072"></a>00072   }
<a name="l00073"></a>00073 }
<a name="l00074"></a>00074 
<a name="l00075"></a>00075  <span class="comment"></span>
<a name="l00076"></a>00076 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00077"></a>00077 <span class="comment">//!  Main function to simulate x-ray tracks inside a voxelized geometry.</span>
<a name="l00078"></a>00078 <span class="comment">//!  Secondary electrons are not simulated (in photoelectric and Compton </span>
<a name="l00079"></a>00079 <span class="comment">//!  events the energy is locally deposited).</span>
<a name="l00080"></a>00080 <span class="comment">//!</span>
<a name="l00081"></a>00081 <span class="comment">//!  The following global variables, in  the GPU __constant__ memory are used:</span>
<a name="l00082"></a>00082 <span class="comment">//!           voxel_data_CONST, </span>
<a name="l00083"></a>00083 <span class="comment">//!           source_data_CONST,</span>
<a name="l00084"></a>00084 <span class="comment">//!           detector_data_CONST, </span>
<a name="l00085"></a>00085 <span class="comment">//!           mfp_table_data_CONST.</span>
<a name="l00086"></a>00086 <span class="comment">//!</span>
<a name="l00087"></a>00087 <span class="comment">//!       @param[in] history_batch  Particle batch number (only used in the CPU version when CUDA is disabled!, the GPU uses the built-in variable threadIdx)</span>
<a name="l00088"></a>00088 <span class="comment">//!       @param[in] num_p  Projection number in the CT simulation. This variable defines a specific angle and the corresponding source and detector will be used.</span>
<a name="l00089"></a>00089 <span class="comment">//!       @param[in] histories_per_thread   Number of histories to simulate for each call to this function (ie, for GPU thread).</span>
<a name="l00090"></a>00090 <span class="comment">//!       @param[in] seed_input   Random number generator seed (the same seed is used to initialize the two MLCGs of RANECU).</span>
<a name="l00091"></a>00091 <span class="comment">//!       @param[in] voxel_mat_dens   Pointer to the voxel densities and material vector (the voxelized geometry), stored in GPU glbal memory.</span>
<a name="l00092"></a>00092 <span class="comment">//!       @param[in] mfp_Woodcock_table    Two parameter table for the linear interpolation of the Woodcock mean free path (MFP) (stored in GPU global memory).</span>
<a name="l00093"></a>00093 <span class="comment">//!       @param[in] mfp_table_a   First element for the linear interpolation of the interaction mean free paths (stored in GPU global memory).</span>
<a name="l00094"></a>00094 <span class="comment">//!       @param[in] mfp_table_b   Second element for the linear interpolation of the interaction mean free paths (stored in GPU global memory).</span>
<a name="l00095"></a>00095 <span class="comment">//!       @param[in] rayleigh_table   Pointer to the table with the data required by the Rayleigh interaction sampling, stored in GPU global memory.</span>
<a name="l00096"></a>00096 <span class="comment">//!       @param[in] compton_table   Pointer to the table with the data required by the Compton interaction sampling, stored in GPU global memory.</span>
<a name="l00097"></a>00097 <span class="comment">//!       @param[in,out] image   Pointer to the image vector in the GPU glbal memory.</span>
<a name="l00098"></a>00098 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00099"></a>00099 <span class="comment"></span><span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>__global__ <span class="keywordtype">void</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#bca9364385e0606e5a89c50ff0e8d54a" title="Main function to simulate x-ray tracks inside a voxelized geometry.">track_particles</a>(<span class="keywordtype">int</span> histories_per_thread,
<a name="l00101"></a>00101                                 <span class="keywordtype">int</span> num_p,      <span class="comment">// For a CT simulation: allocate space for up to MAX_NUM_PROJECTIONS projections.</span>
<a name="l00102"></a>00102                                 <span class="keywordtype">int</span> seed_input,
<a name="l00103"></a>00103                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>* image,
<a name="l00104"></a>00104                                 float2* voxel_mat_dens,
<a name="l00105"></a>00105                                 float2* mfp_Woodcock_table,
<a name="l00106"></a>00106                                 float3* mfp_table_a,
<a name="l00107"></a>00107                                 float3* mfp_table_b,
<a name="l00108"></a>00108                                 <span class="keyword">struct</span> <a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a>* rayleigh_table,
<a name="l00109"></a>00109                                 <span class="keyword">struct</span> <a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a>* compton_table)
<a name="l00110"></a>00110 <span class="preprocessor">#else</span>
<a name="l00111"></a><a class="code" href="MC-GPU__v1_81_8h.html#bca9364385e0606e5a89c50ff0e8d54a">00111</a> <span class="preprocessor"></span>           <span class="keywordtype">void</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#bca9364385e0606e5a89c50ff0e8d54a" title="Main function to simulate x-ray tracks inside a voxelized geometry.">track_particles</a>(<span class="keywordtype">int</span> history_batch,             <span class="comment">// This variable is not required in the GPU, it uses the thread ID           </span>
<a name="l00112"></a>00112                                 <span class="keywordtype">int</span> histories_per_thread,
<a name="l00113"></a>00113                                 <span class="keywordtype">int</span> num_p,
<a name="l00114"></a>00114                                 <span class="keywordtype">int</span> seed_input,
<a name="l00115"></a>00115                                 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>* image,
<a name="l00116"></a>00116                                 float2* voxel_mat_dens,
<a name="l00117"></a>00117                                 float2* mfp_Woodcock_table,
<a name="l00118"></a>00118                                 float3* mfp_table_a,
<a name="l00119"></a>00119                                 float3* mfp_table_b,
<a name="l00120"></a>00120                                 <span class="keyword">struct</span> <a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a>* rayleigh_table,
<a name="l00121"></a>00121                                 <span class="keyword">struct</span> <a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a>* compton_table)
<a name="l00122"></a>00122 <span class="preprocessor">#endif</span>
<a name="l00123"></a>00123 <span class="preprocessor"></span>{
<a name="l00124"></a>00124   <span class="comment">// -- Declare the track state variables:</span>
<a name="l00125"></a>00125   float3 position, direction;
<a name="l00126"></a>00126   <span class="keywordtype">float</span> energy, step, prob, randno, mfp_density, mfp_Woodcock;
<a name="l00127"></a>00127   float3 mfp_table_read_a, mfp_table_read_b;
<a name="l00128"></a>00128   int2 seed;
<a name="l00129"></a>00129   <span class="keywordtype">int</span> index;
<a name="l00130"></a>00130   <span class="keywordtype">int</span> material0,        <span class="comment">// Current material, starting at 0 for 1st material</span>
<a name="l00131"></a>00131       material_old;     <span class="comment">// Flag to mark a material or energy change</span>
<a name="l00132"></a>00132   <span class="keywordtype">signed</span> <span class="keywordtype">char</span> scatter_state;    <span class="comment">// Flag for scatter images: scatter_state=0 for non-scattered, =1 for Compton, =2 for Rayleigh, and =3 for multiple scatter.</span>
<a name="l00133"></a>00133 
<a name="l00134"></a>00134   <span class="comment">// -- Store the Compton table in shared memory from global memory:</span>
<a name="l00135"></a>00135   <span class="comment">//    For Compton and Rayleigh the access to memory is not coherent and the caching capability do not speeds up the accesses, they actually slows down the acces to other data.</span>
<a name="l00136"></a>00136 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00137"></a>00137 <span class="preprocessor"></span>  __shared__
<a name="l00138"></a>00138 <span class="preprocessor">#endif</span>
<a name="l00139"></a>00139 <span class="preprocessor"></span>  <span class="keyword">struct </span><a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a> cgco_SHARED;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00142"></a>00142 <span class="preprocessor"></span>  __shared__
<a name="l00143"></a>00143 <span class="preprocessor">#endif</span>
<a name="l00144"></a>00144 <span class="preprocessor"></span>  float3 detector_center_SHARED;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00147"></a>00147 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (0==threadIdx.x)  <span class="comment">// First GPU thread copies the variables to shared memory</span>
<a name="l00148"></a>00148   {
<a name="l00149"></a>00149 <span class="preprocessor">#endif</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span>    <span class="comment">// -Copy the compton data to shared memory:</span>
<a name="l00151"></a>00151     cgco_SHARED = *compton_table;
<a name="l00152"></a>00152     <span class="comment">// -Store in shared memory the center of the detector straight ahead of the focal spot, for the present projection (used by "tally_image").</span>
<a name="l00153"></a>00153     detector_center_SHARED.x = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[num_p].x + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[num_p].x * <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>;
<a name="l00154"></a>00154     detector_center_SHARED.y = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[num_p].y + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[num_p].y * <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>;
<a name="l00155"></a>00155     detector_center_SHARED.z = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[num_p].z + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[num_p].z * <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>;
<a name="l00156"></a>00156 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00157"></a>00157 <span class="preprocessor"></span>  }
<a name="l00158"></a>00158 <span class="preprocessor">#endif</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 
<a name="l00162"></a>00162   <span class="comment">// -- Initialize the RANECU generator in a position far away from the previous history:</span>
<a name="l00163"></a>00163 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00164"></a>00164 <span class="preprocessor"></span>  <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#e7bd0b93b4d5eedb15822fa0ef622b48" title="Initialize the pseudo-random number generator (PRNG) RANECU to a position far away...">init_PRNG</a>((threadIdx.x + blockIdx.x*blockDim.x), histories_per_thread, seed_input, &amp;seed);   <span class="comment">// Using a 1D block</span>
<a name="l00165"></a>00165 <span class="preprocessor">#else</span>
<a name="l00166"></a>00166 <span class="preprocessor"></span>  <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#e7bd0b93b4d5eedb15822fa0ef622b48" title="Initialize the pseudo-random number generator (PRNG) RANECU to a position far away...">init_PRNG</a>(history_batch, histories_per_thread, seed_input, &amp;seed);
<a name="l00167"></a>00167 <span class="preprocessor">#endif</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span> 
<a name="l00169"></a>00169   <span class="comment">// -- Store the energy bin and Woodcock MFP for the single energy of the source</span>
<a name="l00170"></a>00170          <span class="comment">// !!DeBuG!! Not valid for a source with an energy spectra (this gives about ~10% speed up for a monoenergetic x-ray beam). </span>
<a name="l00171"></a>00171   float2 mfp_Woodcock_read;
<a name="l00172"></a>00172 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span>  __shared__
<a name="l00174"></a>00174 <span class="preprocessor">#endif</span>
<a name="l00175"></a>00175 <span class="preprocessor"></span>  <span class="keywordtype">int</span> index_E0;
<a name="l00176"></a>00176 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00177"></a>00177 <span class="preprocessor"></span>  __shared__
<a name="l00178"></a>00178 <span class="preprocessor">#endif   </span>
<a name="l00179"></a>00179 <span class="preprocessor"></span>  <span class="keywordtype">float</span> mfp_Woodcock_E0;
<a name="l00180"></a>00180     
<a name="l00181"></a>00181 <span class="preprocessor">#ifdef USING_CUDA  </span>
<a name="l00182"></a>00182 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (0==threadIdx.x)
<a name="l00183"></a>00183   {  
<a name="l00184"></a>00184 <span class="preprocessor">#endif  </span>
<a name="l00185"></a>00185 <span class="preprocessor"></span>    index_E0 = (int)((<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#9e48c14733a7848fa9e038088c18847a">energy</a> - <a class="code" href="MC-GPU__v1_81_8h.html#8a3e410fb23d04f8a27d3d71c2381d24" title="Global variable to be stored in the GPU constant memory defining the linear interpolation...">mfp_table_data_CONST</a>.<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a>)*<a class="code" href="MC-GPU__v1_81_8h.html#8a3e410fb23d04f8a27d3d71c2381d24" title="Global variable to be stored in the GPU constant memory defining the linear interpolation...">mfp_table_data_CONST</a>.<a class="code" href="structlinear__interp.html#4b743ecf01ca7d075cc6b36b9ce2f0a1">ide</a>);   <span class="comment">// Truncating to int because initial energy always &gt; e0</span>
<a name="l00186"></a>00186     mfp_Woodcock_read = mfp_Woodcock_table[index_E0];   <span class="comment">// Read the 2 parameters for the linear interpolation in a single read from global memory</span>
<a name="l00187"></a>00187     mfp_Woodcock_E0 = mfp_Woodcock_read.x + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#9e48c14733a7848fa9e038088c18847a">energy</a> * mfp_Woodcock_read.y;   <span class="comment">// Interpolated minimum MFP for monoenergetic source</span>
<a name="l00188"></a>00188 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00189"></a>00189 <span class="preprocessor"></span>  }
<a name="l00190"></a>00190   __syncthreads();     <span class="comment">// Make sure all threads will see the initialized shared variable</span>
<a name="l00191"></a>00191 <span class="preprocessor">#endif  </span>
<a name="l00192"></a>00192 <span class="preprocessor"></span>
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 
<a name="l00195"></a>00195   <span class="comment">// -- Loop for the "histories_per_thread" particles in the current history_batch:</span>
<a name="l00196"></a>00196 
<a name="l00197"></a>00197   <span class="keywordflow">for</span>( ; histories_per_thread&gt;0; histories_per_thread--)
<a name="l00198"></a>00198   {
<a name="l00199"></a>00199     <span class="comment">//     printf("\n\n********* NEW HISTORY:  %d    [seeds: %d, %d]\n\n",histories_per_thread, seed.x, seed.y); fflush(stdout);</span>
<a name="l00200"></a>00200 
<a name="l00201"></a>00201     <span class="keywordtype">int</span> absvox = 1;
<a name="l00202"></a>00202     
<a name="l00203"></a>00203     <span class="comment">// -- Call the source function to get a primary x ray:</span>
<a name="l00204"></a>00204     <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#d58a7b0dc497439d0d63e9015b0aa0cb" title="Source that creates primary x rays, according to the defined source model.">source</a>(&amp;num_p, &amp;position, &amp;direction, &amp;energy, &amp;seed, &amp;absvox);
<a name="l00205"></a>00205 
<a name="l00206"></a>00206     scatter_state = (<span class="keywordtype">signed</span> char)0;     <span class="comment">// Reset previous scatter state: new non-scattered particle loaded</span>
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     <span class="comment">// -- Find the current energy bin by truncation:</span>
<a name="l00209"></a>00209       <span class="comment">// index = (short int)((energy-mfp_table_data_CONST.e0)*mfp_table_data_CONST.ide);</span>
<a name="l00210"></a>00210     index = index_E0;     <span class="comment">// !!DeBuG!! Valid only for monoenergetic beam</span>
<a name="l00211"></a>00211 
<a name="l00212"></a>00212     material_old  = -1;     <span class="comment">// Reset previous material (negative materials are not allowed).</span>
<a name="l00213"></a>00213 
<a name="l00214"></a>00214     <span class="comment">// -- Get the minimum mfp at the current energy using linear interpolation (Woodcock trick):</span>
<a name="l00215"></a>00215       <span class="comment">// float2 mfp_Woodcock_read = mfp_Woodcock_table[index];   // Read the 2 parameters for the linear interpolation in a single read ffrom global memory</span>
<a name="l00216"></a>00216       <span class="comment">// float mfp_Woodcock = mfp_Woodcock_read.x + energy * mfp_Woodcock_read.y;   // Interpolated minimum MFP</span>
<a name="l00217"></a>00217     mfp_Woodcock = mfp_Woodcock_E0;     <span class="comment">// !!DeBuG!! Valid only for monoenergetic beam</span>
<a name="l00218"></a>00218     
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     <span class="comment">// *** X-ray interaction loop:</span>
<a name="l00221"></a>00221     <span class="keywordflow">for</span>(;;)
<a name="l00222"></a>00222     {
<a name="l00223"></a>00223 
<a name="l00224"></a>00224       <span class="keywordflow">if</span> (absvox&lt;0)
<a name="l00225"></a>00225         <span class="keywordflow">break</span>;    <span class="comment">// -- Primary particle was not pointing to the voxel region! (but may still be detected after moving in vacuum in a straight line).</span>
<a name="l00226"></a>00226     
<a name="l00227"></a>00227       step = -(mfp_Woodcock)*logf(<a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(&amp;seed));   <span class="comment">// Using the minimum MFP in the geometry for the input energy (Woodcock trick)</span>
<a name="l00228"></a>00228         
<a name="l00229"></a>00229       position.x += step*direction.x;
<a name="l00230"></a>00230       position.y += step*direction.y;
<a name="l00231"></a>00231       position.z += step*direction.z;
<a name="l00232"></a>00232 
<a name="l00233"></a>00233       <span class="comment">// -- Locate the new particle in the voxel geometry:</span>
<a name="l00234"></a>00234       absvox = <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#6ce03af860514f703cbf18f217ec1df0" title="Find the voxel that contains the current position.">locate_voxel</a>(&amp;position);   <span class="comment">// Get the voxel number at the current position.</span>
<a name="l00235"></a>00235       <span class="keywordflow">if</span> (absvox&lt;0)
<a name="l00236"></a>00236         <span class="keywordflow">break</span>;    <span class="comment">// -- Particle escaped the voxel region! ("index" is still &gt;0 at this moment)</span>
<a name="l00237"></a>00237       float2 matdens = voxel_mat_dens[absvox];     <span class="comment">// Get the voxel material and density in a single read from global memory</span>
<a name="l00238"></a>00238       material0 = matdens.x - 1;   <span class="comment">// Set the current material by truncation, and set 1st material to value '0'.</span>
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 
<a name="l00241"></a>00241       <span class="comment">// -- Get the data for the linear interpolation of the interaction MFPs, in case the energy or material have changed:</span>
<a name="l00242"></a>00242       <span class="keywordflow">if</span> (material0 != material_old)
<a name="l00243"></a>00243       {
<a name="l00244"></a>00244         mfp_table_read_a = mfp_table_a[index*(<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>)+material0];
<a name="l00245"></a>00245         mfp_table_read_b = mfp_table_b[index*(<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>)+material0];
<a name="l00246"></a>00246         material_old = material0;                                              <span class="comment">// Store the new material</span>
<a name="l00247"></a>00247       }
<a name="l00248"></a>00248 
<a name="l00249"></a>00249       
<a name="l00250"></a>00250       <span class="comment">// *** Apply Woodcock trick:</span>
<a name="l00251"></a>00251       mfp_density = mfp_Woodcock * matdens.y;
<a name="l00252"></a>00252       <span class="comment">// -- Calculate probability of delta scattering, using the total mean free path for the current material and energy (linear interpolation):</span>
<a name="l00253"></a>00253       prob = 1.0f - mfp_density * (mfp_table_read_a.x + energy * mfp_table_read_b.x);
<a name="l00254"></a>00254       randno = <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(&amp;seed);    <span class="comment">// Sample uniform PRN</span>
<a name="l00255"></a>00255 
<a name="l00256"></a>00256       <span class="keywordflow">if</span> (randno&lt;prob)   <span class="comment">// [Checking delta scattering]</span>
<a name="l00257"></a>00257       {
<a name="l00258"></a>00258         <span class="comment">// *** No real event; continue jumping:</span>
<a name="l00259"></a>00259         <span class="keywordflow">continue</span>;
<a name="l00260"></a>00260       }
<a name="l00261"></a>00261       <span class="keywordflow">else</span>
<a name="l00262"></a>00262       {      
<a name="l00263"></a>00263         prob += mfp_density * (mfp_table_read_a.y + energy * mfp_table_read_b.y);    <span class="comment">// Interpolate total Compton MFP ('y' component)</span>
<a name="l00264"></a>00264         <span class="keywordflow">if</span> (randno&lt;prob)   <span class="comment">// [Checking Compton scattering]</span>
<a name="l00265"></a>00265         {
<a name="l00266"></a>00266           <span class="comment">// *** Compton interaction:</span>
<a name="l00267"></a>00267 
<a name="l00268"></a>00268           <span class="comment">//  -- Sample new direction and energy:</span>
<a name="l00269"></a>00269           <span class="keywordtype">double</span> costh_Compton;   <span class="comment">// Energy lost in the Compton interaction and angular deflection.</span>
<a name="l00270"></a>00270           <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#6f212862e7fba1553ec9495f05443b2c" title="Random sampling of incoherent (Compton) scattering of photons, using the sampling...">GCOa</a>(&amp;energy, &amp;costh_Compton, &amp;material0, &amp;seed, &amp;cgco_SHARED);
<a name="l00271"></a>00271           <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#94ad9ed794eb8fd696e7e357ae391765" title="Rotates a vector; the rotation is specified by giving the polar and azimuthal angles...">rotate_double</a>(&amp;direction, costh_Compton, <span class="comment">/*phi=2*pi*PRN=*/</span> 6.28318530717958647693*<a class="code" href="MC-GPU__kernel__v1_81_8cu.html#74c4894502584f8fb113e04b759a6c55" title="Pseudo-random number generator (PRNG) RANECU returning a double value.">ranecu_double</a>(&amp;seed));
<a name="l00272"></a>00272 
<a name="l00273"></a>00273           <span class="comment">// -- Find the new energy interval:</span>
<a name="l00274"></a>00274 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00275"></a>00275 <span class="preprocessor"></span>          index = __float2int_rd((energy-<a class="code" href="MC-GPU__v1_81_8h.html#8a3e410fb23d04f8a27d3d71c2381d24" title="Global variable to be stored in the GPU constant memory defining the linear interpolation...">mfp_table_data_CONST</a>.<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a>)*<a class="code" href="MC-GPU__v1_81_8h.html#8a3e410fb23d04f8a27d3d71c2381d24" title="Global variable to be stored in the GPU constant memory defining the linear interpolation...">mfp_table_data_CONST</a>.<a class="code" href="structlinear__interp.html#4b743ecf01ca7d075cc6b36b9ce2f0a1">ide</a>);  <span class="comment">// Using CUDA function to convert float to integer rounding down (towards minus infinite)</span>
<a name="l00276"></a>00276 <span class="preprocessor">#else</span>
<a name="l00277"></a>00277 <span class="preprocessor"></span>          index = (int)(floor((energy-<a class="code" href="MC-GPU__v1_81_8h.html#8a3e410fb23d04f8a27d3d71c2381d24" title="Global variable to be stored in the GPU constant memory defining the linear interpolation...">mfp_table_data_CONST</a>.<a class="code" href="structlinear__interp.html#c07eade974afb1b75d16516d1eb55a33">e0</a>)*<a class="code" href="MC-GPU__v1_81_8h.html#8a3e410fb23d04f8a27d3d71c2381d24" title="Global variable to be stored in the GPU constant memory defining the linear interpolation...">mfp_table_data_CONST</a>.<a class="code" href="structlinear__interp.html#4b743ecf01ca7d075cc6b36b9ce2f0a1">ide</a>));    <span class="comment">// !!DeBuG!! Should add EPSILON to make sure truncation to int (towards minus infinite) is correct??</span>
<a name="l00278"></a>00278 <span class="preprocessor">#endif          </span>
<a name="l00279"></a>00279 <span class="preprocessor"></span>
<a name="l00280"></a>00280           <span class="keywordflow">if</span> (index&lt;0)
<a name="l00281"></a>00281             <span class="keywordflow">break</span>;    <span class="comment">// Energy below minimum: particle will be absorbed (or rejected) outside the loop.</span>
<a name="l00282"></a>00282 
<a name="l00283"></a>00283           <span class="comment">// -- Get the Woodcock MFP for the new energy:</span>
<a name="l00284"></a>00284           mfp_Woodcock_read = mfp_Woodcock_table[index];   <span class="comment">// Read the 2 parameters for the linear interpolation in a single read ffrom global memory</span>
<a name="l00285"></a>00285           mfp_Woodcock = mfp_Woodcock_read.x + energy * mfp_Woodcock_read.y;   <span class="comment">// Interpolated minimum MFP</span>
<a name="l00286"></a>00286 
<a name="l00287"></a>00287 
<a name="l00288"></a>00288           material_old = -2;    <span class="comment">// Set an impossible material to force an update of the MFPs data for the nex energy interval</span>
<a name="l00289"></a>00289 
<a name="l00290"></a>00290           <span class="comment">// -- Update scatter state:</span>
<a name="l00291"></a>00291           <span class="keywordflow">if</span> (scatter_state==(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>)0)
<a name="l00292"></a>00292             scatter_state = (<span class="keywordtype">signed</span> <span class="keywordtype">char</span>)1;   <span class="comment">// Set scatter_state == 1: Compton scattered particle</span>
<a name="l00293"></a>00293           <span class="keywordflow">else</span>
<a name="l00294"></a>00294             scatter_state = (<span class="keywordtype">signed</span> char)3;   <span class="comment">// Set scatter_state == 3: Multi-scattered particle</span>
<a name="l00295"></a>00295 
<a name="l00296"></a>00296         }
<a name="l00297"></a>00297         <span class="keywordflow">else</span>
<a name="l00298"></a>00298         {
<a name="l00299"></a>00299           prob += mfp_density * (mfp_table_read_a.z + energy * mfp_table_read_b.z);    <span class="comment">// Interpolate total Rayleigh MFP ('z' component)</span>
<a name="l00300"></a>00300           <span class="keywordflow">if</span> (randno&lt;prob)   <span class="comment">// [Checking Rayleigh scattering]</span>
<a name="l00301"></a>00301           {
<a name="l00302"></a>00302             <span class="comment">// *** Rayleigh interaction:</span>
<a name="l00303"></a>00303 
<a name="l00304"></a>00304             <span class="comment">//  -- Sample angular deflection:</span>
<a name="l00305"></a>00305             <span class="keywordtype">double</span> costh_Rayleigh;
<a name="l00306"></a>00306             <span class="keywordtype">float</span> pmax_current = rayleigh_table-&gt;<a class="code" href="structrayleigh__struct.html#14a41a17bf4ad8a1e87f43d9f42021ad">pmax</a>[(index+1)*<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>+material0];   <span class="comment">// Get max (ie, value for next bin?) cumul prob square form factor for Rayleigh sampling</span>
<a name="l00307"></a>00307 
<a name="l00308"></a>00308             <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#5cafd4ebb3d155746b16ca7d231ecad1" title="Sample a Rayleigh interaction using the sampling algorithm used in PENELOPE 2006...">GRAa</a>(&amp;energy, &amp;costh_Rayleigh, &amp;material0, &amp;pmax_current, &amp;seed, rayleigh_table);
<a name="l00309"></a>00309             <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#94ad9ed794eb8fd696e7e357ae391765" title="Rotates a vector; the rotation is specified by giving the polar and azimuthal angles...">rotate_double</a>(&amp;direction, costh_Rayleigh, <span class="comment">/*phi=2*pi*PRN=*/</span> 6.28318530717958647693*<a class="code" href="MC-GPU__kernel__v1_81_8cu.html#74c4894502584f8fb113e04b759a6c55" title="Pseudo-random number generator (PRNG) RANECU returning a double value.">ranecu_double</a>(&amp;seed));
<a name="l00310"></a>00310 
<a name="l00311"></a>00311             <span class="comment">// -- Update scatter state:</span>
<a name="l00312"></a>00312             <span class="keywordflow">if</span> (scatter_state==(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>)0)
<a name="l00313"></a>00313               scatter_state = (<span class="keywordtype">signed</span> char)2;   <span class="comment">// Set scatter_state == 1: Rayleigh scattered particle</span>
<a name="l00314"></a>00314             <span class="keywordflow">else</span>
<a name="l00315"></a>00315               scatter_state = (<span class="keywordtype">signed</span> char)3;   <span class="comment">// Set scatter_state == 3: Multi-scattered particle</span>
<a name="l00316"></a>00316 
<a name="l00317"></a>00317           }
<a name="l00318"></a>00318           <span class="keywordflow">else</span>
<a name="l00319"></a>00319           {
<a name="l00320"></a>00320             <span class="comment">// *** Photoelectric interaction (or pair production): absorb particle!</span>
<a name="l00321"></a>00321 
<a name="l00322"></a>00322             index = -11;   <span class="comment">// A negative "index" marks that the energy has to be deposited, particle will not arrive at the detector</span>
<a name="l00323"></a>00323             <span class="keywordflow">break</span>;
<a name="l00324"></a>00324           }
<a name="l00325"></a>00325         }
<a name="l00326"></a>00326       }
<a name="l00327"></a>00327     }
<a name="l00328"></a>00328 
<a name="l00329"></a>00329     <span class="keywordflow">if</span> (index&gt;-1)
<a name="l00330"></a>00330     {
<a name="l00331"></a>00331       <span class="comment">// -- Particle escaped the voxels but was not absorbed, check if it will arrive at the detector and tally its energy:</span>
<a name="l00332"></a>00332       <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#72817a5712f873a61ad5408a781620be" title="Tally a radiographic projection image.">tally_image</a>(&amp;num_p, &amp;energy, &amp;position, &amp;direction, &amp;scatter_state, image, &amp;detector_center_SHARED);
<a name="l00333"></a>00333     }
<a name="l00334"></a>00334   }   <span class="comment">// [Continue with a new history]</span>
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 }   <span class="comment">// [All tracks simulated for this kernel call: return to CPU]</span>
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 
<a name="l00340"></a>00340 <span class="comment"></span>
<a name="l00341"></a>00341 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00342"></a>00342 <span class="comment">//!  Tally a radiographic projection image.</span>
<a name="l00343"></a>00343 <span class="comment">//!  This function is called whenever a particle escapes the voxelized volume.</span>
<a name="l00344"></a>00344 <span class="comment">//!  The code checks if the particle would arrive at the detector if it kept</span>
<a name="l00345"></a>00345 <span class="comment">//!  moving in a straight line after exiting the voxels (assuming vacuum enclosure).</span>
<a name="l00346"></a>00346 <span class="comment">//!  An ideal image formation model is implemented: each pixel counts the total energy</span>
<a name="l00347"></a>00347 <span class="comment">//!  of the x rays that enter the pixel (100% detection efficiency for any energy).</span>
<a name="l00348"></a>00348 <span class="comment">//!  The image due to primaries and different kinds of scatter is tallied separately.</span>
<a name="l00349"></a>00349 <span class="comment">//!</span>
<a name="l00350"></a>00350 <span class="comment">//!  In the GPU, and atomicAdd() function is used to make sure that multiple threads do</span>
<a name="l00351"></a>00351 <span class="comment">//!  not update the same pixel at the same time, which would result in a lose of information.</span>
<a name="l00352"></a>00352 <span class="comment">//!  Since the atomicAdd function is only available for 'unsigned long long int' data,</span>
<a name="l00353"></a>00353 <span class="comment">//!  the float pixel values are scaled by a factor "SCALE_eV" defined in the header file</span>
<a name="l00354"></a>00354 <span class="comment">//!  (eg, #define SCALE_eV 10000.0f) and stored as unsigned long long integers in main</span>
<a name="l00355"></a>00355 <span class="comment">//!  memory.</span>
<a name="l00356"></a>00356 <span class="comment">//!</span>
<a name="l00357"></a>00357 <span class="comment">//!  WARNING! If the total tallied signal (for all particles) is larger than "1.8e19/SCALE_eV",</span>
<a name="l00358"></a>00358 <span class="comment">//!  there will be a bit overflow and the value will be reset to 0 giving bogus results.</span>
<a name="l00359"></a>00359 <span class="comment">//!</span>
<a name="l00360"></a>00360 <span class="comment">//!</span>
<a name="l00361"></a>00361 <span class="comment">//!       @param[in] energy   X-ray energy</span>
<a name="l00362"></a>00362 <span class="comment">//!       @param[in] position   Particle position</span>
<a name="l00363"></a>00363 <span class="comment">//!       @param[in] direction   Particle direction (cosine vectors)</span>
<a name="l00364"></a>00364 <span class="comment">//!       @param[in] scatter_state  Flag marking primaries, single Compton, single Rayleigh or multiple scattered radiation</span>
<a name="l00365"></a>00365 <span class="comment">//!       @param[out] image   Integer array containing the image, ie, the pixel values (in tenths of meV)</span>
<a name="l00366"></a>00366 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00367"></a>00367 <span class="comment"></span><span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00368"></a>00368 <span class="preprocessor"></span>__device__
<a name="l00369"></a>00369 <span class="preprocessor">#endif</span>
<a name="l00370"></a><a class="code" href="MC-GPU__v1_81_8h.html#72817a5712f873a61ad5408a781620be">00370</a> <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#72817a5712f873a61ad5408a781620be" title="Tally a radiographic projection image.">tally_image</a>(<span class="keywordtype">int</span>* num_p, <span class="keywordtype">float</span>* energy, float3* position, float3* direction, <span class="keywordtype">signed</span> <span class="keywordtype">char</span>* scatter_state, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>* image, float3* detector_center_SHARED)
<a name="l00371"></a>00371 {
<a name="l00372"></a>00372   <span class="keywordtype">float</span> dist_detector, rotated_position;
<a name="l00373"></a>00373 
<a name="l00374"></a>00374   <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#dbe41a01886ae097dac0fa908551d035">rotation_flag</a> == 1)    <span class="comment">// --&gt;  Initial source direction is not (0,1,0): detector has to be rotated to +Y to find the pixel number</span>
<a name="l00375"></a>00375   {
<a name="l00376"></a>00376     <span class="comment">// *** Find the distance from the current particle location (likely just after the edge of the voxel bbox) to the intersection with the detector plane:</span>
<a name="l00377"></a>00377     <span class="comment">//     (NOTE: the particle was moved outside the voxel region and not turned back, therefore if the detector is very close to the voxels the distance could be negative and the algorithm fail! However this is unlikely with the short mfp_Woodcock !!DeBuG!!).</span>
<a name="l00378"></a>00378     dist_detector = ( <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[*num_p].x * (detector_center_SHARED-&gt;x - position-&gt;x) +
<a name="l00379"></a>00379                       <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[*num_p].y * (detector_center_SHARED-&gt;y - position-&gt;y) +
<a name="l00380"></a>00380                       <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[*num_p].z * (detector_center_SHARED-&gt;z - position-&gt;z) ) /
<a name="l00381"></a>00381                     ( <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[*num_p].x * direction-&gt;x + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[*num_p].y * direction-&gt;y + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#454982da7850cccc15946310cf6f5f35">direction</a>[*num_p].z * direction-&gt;z );
<a name="l00382"></a>00382 
<a name="l00383"></a>00383     <span class="comment">// *** Eliminate particles not moving towards the detector (dist&lt;0) or that intersect the detector plane</span>
<a name="l00384"></a>00384     <span class="comment">//     too far away (max dist arbitrarily set to the source-to-detector distance):   // !!DeBuG!! NOTE: This may give problems for big detectors very close to the source</span>
<a name="l00385"></a>00385     <span class="keywordflow">if</span> (dist_detector&lt;0.0f || dist_detector&gt;(2.0f*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>))    
<a name="l00386"></a>00386       <span class="keywordflow">return</span>;
<a name="l00387"></a>00387     
<a name="l00388"></a>00388     <span class="comment">// *** Translate the particle to the detector plane (we assume the detector is completely absorbent: 100% detection efficiency):</span>
<a name="l00389"></a>00389     position-&gt;x = position-&gt;x + dist_detector * direction-&gt;x;
<a name="l00390"></a>00390     position-&gt;y = position-&gt;y + dist_detector * direction-&gt;y;
<a name="l00391"></a>00391     position-&gt;z = position-&gt;z + dist_detector * direction-&gt;z;
<a name="l00392"></a>00392 
<a name="l00393"></a>00393     <span class="comment">// *** Rotate the particle position vector to a reference system where the detector is perpendicular to the +Y axis to find out if the particle is inside a pixel:</span>
<a name="l00394"></a>00394 <span class="preprocessor">    #ifdef USING_CUDA</span>
<a name="l00395"></a>00395 <span class="preprocessor"></span>      rotated_position = <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][0]*position-&gt;x + <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][1]*position-&gt;y + <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][2]*position-&gt;z;  <span class="comment">// X coordinate</span>
<a name="l00396"></a>00396       <span class="keywordtype">int</span> pixel_coord_x = __float2int_rd((rotated_position - <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[*num_p].x) * <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#3c6f9e59e89db06211ccea63287e2826">inv_pixel_size_X</a>);    <span class="comment">// Using CUDA intrinsic function to convert float to integer rounding down (towards minus infinite)</span>
<a name="l00397"></a>00397       <span class="keywordflow">if</span> ((pixel_coord_x&gt;-1)&amp;&amp;(pixel_coord_x&lt;<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x))
<a name="l00398"></a>00398       {
<a name="l00399"></a>00399         rotated_position = <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][6]*position-&gt;x + <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][7]*position-&gt;y + <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][8]*position-&gt;z;  <span class="comment">// Z coordinate</span>
<a name="l00400"></a>00400         <span class="keywordtype">int</span> pixel_coord_z = __float2int_rd((rotated_position - <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[*num_p].z) * <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#a91fc94f674ad7af8eca577f4d8cd22b">inv_pixel_size_Z</a>);
<a name="l00401"></a>00401         <span class="keywordflow">if</span> ((pixel_coord_z&gt;-1)&amp;&amp;(pixel_coord_z&lt;<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y))
<a name="l00402"></a>00402         {
<a name="l00403"></a>00403           <span class="comment">// -- Particle enters the detector! Tally the particle energy in the corresponding pixel (in tenths of meV):</span>
<a name="l00404"></a>00404           <span class="comment">//    Using a CUDA atomic function (not available for global floats yet) to read and increase the pixel value in a single instruction, blocking interferences from other threads.</span>
<a name="l00405"></a>00405           <span class="comment">//    The offset for the primaries or scatter images are calculated considering that:</span>
<a name="l00406"></a>00406           <span class="comment">//      scatter_state=0 for non-scattered, =1 for Compton, =2 for Rayleigh, and =3 for multiple scatter.</span>
<a name="l00407"></a>00407           atomicAdd(( image +                                                               <span class="comment">// Pointer to beginning of image array</span>
<a name="l00408"></a>00408                     (<span class="keywordtype">int</span>)(*scatter_state) * <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#c26d0b66ebf521346d8ba07609340ea6">total_num_pixels</a> +         <span class="comment">// Offset to corresponding scatter image</span>
<a name="l00409"></a>00409                     (pixel_coord_x + pixel_coord_z*(<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x)) ),  <span class="comment">// Offset to the corresponding pixel</span>
<a name="l00410"></a>00410                     __float2ull_rn((*energy)*<a class="code" href="MC-GPU__v1_81_8h.html#c0c03cf5e803404f5dc2a42467395a3a" title="Value to scale the deposited energy in the pixels so that it can be stored as a long...">SCALE_eV</a>) );     <span class="comment">// Energy arriving at the pixel, scaled by the factor SCALE_eV and rounded.</span>
<a name="l00411"></a>00411                                                               <span class="comment">// The maximum unsigned long long int value is ~1.8e19:</span>
<a name="l00412"></a>00412         }
<a name="l00413"></a>00413       }
<a name="l00414"></a>00414 <span class="preprocessor">    #else</span>
<a name="l00415"></a>00415 <span class="preprocessor"></span>      <span class="comment">// CPU version (not using CUDA intrinsics: atomicAdd, fast type casting)</span>
<a name="l00416"></a>00416       rotated_position = <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][0]*position-&gt;x + <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][1]*position-&gt;y + <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][2]*position-&gt;z;  <span class="comment">// X coordinate</span>
<a name="l00417"></a>00417       <span class="keywordtype">int</span> pixel_coord_x = (int)(floor((rotated_position - <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[*num_p].x)*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#3c6f9e59e89db06211ccea63287e2826">inv_pixel_size_X</a>));  <span class="comment">// !!DeBuG!! should I add EPS??</span>
<a name="l00418"></a>00418 
<a name="l00419"></a>00419       <span class="keywordflow">if</span> ((pixel_coord_x&gt;-1)&amp;&amp;(pixel_coord_x&lt;<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x))
<a name="l00420"></a>00420       {
<a name="l00421"></a>00421         rotated_position = <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][6]*position-&gt;x + <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][7]*position-&gt;y + <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#bdcc10e8191d5d48509772b2f5bc01aa">rot_inv</a>[*num_p][8]*position-&gt;z;  <span class="comment">// Z coordinate</span>
<a name="l00422"></a>00422         <span class="keywordtype">int</span> pixel_coord_z = (int)(<span class="comment">/*EPS +*/</span> floor((rotated_position - <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[*num_p].z)*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#a91fc94f674ad7af8eca577f4d8cd22b">inv_pixel_size_Z</a>));
<a name="l00423"></a>00423         <span class="keywordflow">if</span> ((pixel_coord_z&gt;-1)&amp;&amp;(pixel_coord_z&lt;<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y))
<a name="l00424"></a>00424           image[((int)(*scatter_state))*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#c26d0b66ebf521346d8ba07609340ea6">total_num_pixels</a> + pixel_coord_x + pixel_coord_z*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x] += (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>)((*energy)*<a class="code" href="MC-GPU__v1_81_8h.html#c0c03cf5e803404f5dc2a42467395a3a" title="Value to scale the deposited energy in the pixels so that it can be stored as a long...">SCALE_eV</a> + 0.5f);  <span class="comment">// Tally the particle energy in the pixel. This instruction is not thread-safe, but it is ok in sequential code.          </span>
<a name="l00425"></a>00425       }
<a name="l00426"></a>00426 <span class="preprocessor">    #endif</span>
<a name="l00427"></a>00427 <span class="preprocessor"></span>  }
<a name="l00428"></a>00428   <span class="keywordflow">else</span>  <span class="comment">// (detector_data_CONST.rotation_flag != 1) --&gt;  Initial source direction is (0,1,0): pixel number and distance can be found easily</span>
<a name="l00429"></a>00429   {
<a name="l00430"></a>00430         <span class="comment">// !!DeBuG!! Check that the codes for +Y and rotated detector are equivalent and that the +Y case is faster than the general case (otherwise simplify the code).</span>
<a name="l00431"></a>00431   
<a name="l00432"></a>00432     <span class="keywordflow">if</span> (direction-&gt;y &lt; 0.0001f)
<a name="l00433"></a>00433       <span class="keywordflow">return</span>;  <span class="comment">// *** Reject particles not moving towards the detector plane at +Y.</span>
<a name="l00434"></a>00434 
<a name="l00435"></a>00435     dist_detector = (detector_center_SHARED-&gt;y - position-&gt;y)/(direction-&gt;y);  <span class="comment">// Distance to the intersection with the detector at +Y.</span>
<a name="l00436"></a>00436 
<a name="l00437"></a>00437     <span class="keywordflow">if</span> (dist_detector&gt;(2.0f*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#781104d94879829947e6c863ee17abb5">sdd</a>))
<a name="l00438"></a>00438       <span class="keywordflow">return</span>;  <span class="comment">// *** Eliminate particles that intersect the detector plane too far away</span>
<a name="l00439"></a>00439      
<a name="l00440"></a>00440 <span class="preprocessor">    #ifdef USING_CUDA</span>
<a name="l00441"></a>00441 <span class="preprocessor"></span>    <span class="keywordtype">int</span> pixel_coord_x = __float2int_rd((position-&gt;x + dist_detector*direction-&gt;x - <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[*num_p].x)*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#3c6f9e59e89db06211ccea63287e2826">inv_pixel_size_X</a>);
<a name="l00442"></a>00442     <span class="keywordflow">if</span> ((pixel_coord_x&gt;-1)&amp;&amp;(pixel_coord_x&lt;<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x))
<a name="l00443"></a>00443     {
<a name="l00444"></a>00444       <span class="keywordtype">int</span> pixel_coord_z = __float2int_rd((position-&gt;z + dist_detector*direction-&gt;z - <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[*num_p].z)*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#a91fc94f674ad7af8eca577f4d8cd22b">inv_pixel_size_Z</a>);
<a name="l00445"></a>00445       <span class="keywordflow">if</span> ((pixel_coord_z&gt;-1)&amp;&amp;(pixel_coord_z&lt;<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y))
<a name="l00446"></a>00446         atomicAdd( ( image +                                                                <span class="comment">// Pointer to beginning of image array</span>
<a name="l00447"></a>00447                      (<span class="keywordtype">int</span>)(*scatter_state) * <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#c26d0b66ebf521346d8ba07609340ea6">total_num_pixels</a> +         <span class="comment">// Offset to corresponding scatter image</span>
<a name="l00448"></a>00448                      (pixel_coord_x + pixel_coord_z*(<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x)) ),  <span class="comment">// Offset to the corresponding pixel</span>
<a name="l00449"></a>00449                    __float2ull_rn((*energy)*<a class="code" href="MC-GPU__v1_81_8h.html#c0c03cf5e803404f5dc2a42467395a3a" title="Value to scale the deposited energy in the pixels so that it can be stored as a long...">SCALE_eV</a>) );    <span class="comment">// Energy arriving at the pixel, scaled by the factor SCALE_eV and rounded.</span>
<a name="l00450"></a>00450     }
<a name="l00451"></a>00451 <span class="preprocessor">    #else</span>
<a name="l00452"></a>00452 <span class="preprocessor"></span>
<a name="l00453"></a>00453     <span class="comment">// --Calculate the pixel the xray enters, truncating towards minus infinite and making sure the conversion to int is safe:</span>
<a name="l00454"></a>00454     <span class="keywordtype">float</span> pixel_coord_x = floor((position-&gt;x + dist_detector*direction-&gt;x - <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[*num_p].x)*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#3c6f9e59e89db06211ccea63287e2826">inv_pixel_size_X</a>);
<a name="l00455"></a>00455 
<a name="l00456"></a>00456     <span class="keywordflow">if</span> ( (pixel_coord_x&gt;-0.5f) &amp;&amp; (pixel_coord_x&lt;(<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x-0.5f)) )
<a name="l00457"></a>00457     {
<a name="l00458"></a>00458       <span class="keywordtype">float</span> pixel_coord_z = floor((position-&gt;z + dist_detector*direction-&gt;z - <a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#4594770271f7a7bd20e9d213bdec4025">corner_min_rotated_to_Y</a>[*num_p].z)*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#a91fc94f674ad7af8eca577f4d8cd22b">inv_pixel_size_Z</a>);
<a name="l00459"></a>00459       <span class="keywordflow">if</span> ( (pixel_coord_z&gt;-0.5f) &amp;&amp; (pixel_coord_z&lt;(<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.y-0.5f)) )
<a name="l00460"></a>00460         image[((int)(*scatter_state))*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#c26d0b66ebf521346d8ba07609340ea6">total_num_pixels</a> + (<span class="keywordtype">int</span>)(pixel_coord_x+0.001f)+ (<span class="keywordtype">int</span>)(pixel_coord_z+0.001f)*<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#1a30e7168cba7eebe918ab39bb408dce">num_pixels</a>.x] += (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span>)((*energy)*<a class="code" href="MC-GPU__v1_81_8h.html#c0c03cf5e803404f5dc2a42467395a3a" title="Value to scale the deposited energy in the pixels so that it can be stored as a long...">SCALE_eV</a> + 0.5f);
<a name="l00461"></a>00461     }
<a name="l00462"></a>00462 <span class="preprocessor">    #endif</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span>  }
<a name="l00464"></a>00464 }
<a name="l00465"></a>00465 
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="comment"></span>
<a name="l00468"></a>00468 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00469"></a>00469 <span class="comment">//!  Source that creates primary x rays, according to the defined source model.</span>
<a name="l00470"></a>00470 <span class="comment">//!  The particles are automatically moved to the surface of the voxel bounding box,</span>
<a name="l00471"></a>00471 <span class="comment">//!  to start the tracking inside a real material. If the sampled particle do not</span>
<a name="l00472"></a>00472 <span class="comment">//!  enter the voxels, it is init in the focal spot and the main program will check</span>
<a name="l00473"></a>00473 <span class="comment">//!  if it arrives at the detector or not.</span>
<a name="l00474"></a>00474 <span class="comment">//!</span>
<a name="l00475"></a>00475 <span class="comment">//!       @param[in] source_data   Structure describing the source.</span>
<a name="l00476"></a>00476 <span class="comment">//!       @param[out] position   Initial particle position (particle transported inside the voxel bbox).</span>
<a name="l00477"></a>00477 <span class="comment">//!       @param[out] direction   Sampled particle direction (cosine vectors).</span>
<a name="l00478"></a>00478 <span class="comment">//!       @param[out] energy   Sampled energy of the new x ray.</span>
<a name="l00479"></a>00479 <span class="comment">//!       @param[in] seed   Current seed of the random number generator, requiered to sample the movement direction.</span>
<a name="l00480"></a>00480 <span class="comment">//!       @param[out] absvox   Set to &lt;0 if primary particle will not cross the voxels, not changed otherwise (&gt;0).</span>
<a name="l00481"></a>00481 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00482"></a>00482 <span class="comment"></span><span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00483"></a>00483 <span class="preprocessor"></span>__device__
<a name="l00484"></a>00484 <span class="preprocessor">#endif</span>
<a name="l00485"></a><a class="code" href="MC-GPU__v1_81_8h.html#d58a7b0dc497439d0d63e9015b0aa0cb">00485</a> <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#d58a7b0dc497439d0d63e9015b0aa0cb" title="Source that creates primary x rays, according to the defined source model.">source</a>(<span class="keywordtype">int</span>* num_p, float3* position, float3* direction, <span class="keywordtype">float</span>* energy, int2* seed, <span class="keywordtype">int</span>* absvox)
<a name="l00486"></a>00486 {
<a name="l00487"></a>00487   <span class="comment">// *** Assign initial energy (monoenergetic beam):</span>
<a name="l00488"></a>00488   *energy = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#9e48c14733a7848fa9e038088c18847a">energy</a>;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490 
<a name="l00491"></a>00491   <span class="comment">// *** Sample the initial x ray direction with a fan beam ("pyramidal" source):</span>
<a name="l00492"></a>00492 
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 <span class="comment">/* !!DeBuG!! OLD WRONG FAN BEAM:</span>
<a name="l00495"></a>00495 <span class="comment">  // --Sample uniform points on a plane at Y=1cm, centered at (0,+1,0), with the aperture given by the input fan beam:</span>
<a name="l00496"></a>00496 <span class="comment">  direction-&gt;x = source_data_CONST.tan_phi_semiaperture   * (2.0f*ranecu(seed) - 1.0f);</span>
<a name="l00497"></a>00497 <span class="comment">  direction-&gt;y = 1.0f;</span>
<a name="l00498"></a>00498 <span class="comment">  direction-&gt;z = source_data_CONST.tan_theta_semiaperture * (2.0f*ranecu(seed) - 1.0f);</span>
<a name="l00499"></a>00499 <span class="comment">*/</span>
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 
<a name="l00502"></a>00502   <span class="keywordflow">do</span>   <span class="comment">//  Iterate sampling if the sampled direction is not acceptable to get a square field at the given phi (rejection sampling)  //!!DeBuG!! Force square field for any phi!!</span>
<a name="l00503"></a>00503   {
<a name="l00504"></a>00504     <span class="comment">//     Using the algorithm used in PENMAIN.f, from penelope 2008 (by F. Salvat).</span>
<a name="l00505"></a>00505     direction-&gt;z = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#d3b7a93633ec87d036453e54e7e7abad">cos_theta_low</a> + <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(seed)*<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#942289f702f8fc1c6acd411c8ff19efe">D_cos_theta</a>;     <span class="comment">// direction-&gt;z = w = cos(theta_sampled)</span>
<a name="l00506"></a>00506     <span class="keyword">register</span> <span class="keywordtype">float</span> phi_sampled = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#22bb360d294d1a3236e8ba8c4b6d06aa">phi_low</a> + <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(seed)*<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#01b06b35c2bc440ad0091dddde0cad06">D_phi</a>;
<a name="l00507"></a>00507     <span class="keyword">register</span> <span class="keywordtype">float</span> sin_theta_sampled = sqrtf(1.0f - direction-&gt;z*direction-&gt;z);
<a name="l00508"></a>00508     <span class="keywordtype">float</span> sinphi_sampled, cosphi_sampled;
<a name="l00509"></a>00509     sincos(phi_sampled, &amp;sinphi_sampled,&amp;cosphi_sampled);    <span class="comment">// (calculate the SIN and COS at the same time)</span>
<a name="l00510"></a>00510     direction-&gt;y = sin_theta_sampled * sinphi_sampled;
<a name="l00511"></a>00511     direction-&gt;x = sin_theta_sampled * cosphi_sampled;
<a name="l00512"></a>00512   }
<a name="l00513"></a>00513   <span class="keywordflow">while</span>( fabsf(direction-&gt;z/direction-&gt;y) &gt; <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#b1bdb59150b1b055e9149461bc090cf4">max_height_at_y1cm</a> );  <span class="comment">// !!DeBuG!! Force square field for any phi!!</span>
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#dbe41a01886ae097dac0fa908551d035">rotation_flag</a> == 1)
<a name="l00517"></a>00517   {
<a name="l00518"></a>00518     <span class="comment">// --Initial beam not pointing to (0,1,0), apply rotation:</span>
<a name="l00519"></a>00519     <span class="keyword">register</span> <span class="keywordtype">float</span> direction_x_tmp = direction-&gt;x;
<a name="l00520"></a>00520     <span class="keyword">register</span> <span class="keywordtype">float</span> direction_y_tmp = direction-&gt;y;
<a name="l00521"></a>00521     direction-&gt;x = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[*num_p][0]*direction_x_tmp + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[*num_p][1]*direction_y_tmp + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[*num_p][2]*direction-&gt;z;
<a name="l00522"></a>00522     direction-&gt;y = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[*num_p][3]*direction_x_tmp + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[*num_p][4]*direction_y_tmp + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[*num_p][5]*direction-&gt;z;
<a name="l00523"></a>00523     direction-&gt;z = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[*num_p][6]*direction_x_tmp + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[*num_p][7]*direction_y_tmp + <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#f35362a2998f553c4e748b16497452c4">rot_fan</a>[*num_p][8]*direction-&gt;z;
<a name="l00524"></a>00524   }
<a name="l00525"></a>00525 
<a name="l00526"></a>00526 <span class="comment">/* !!DeBuG!! OLD WRONG FAN BEAM:</span>
<a name="l00527"></a>00527 <span class="comment">  // --Normalize the sampled vector (since v==1, it will never be normalized by default):</span>
<a name="l00528"></a>00528 <span class="comment">  #ifdef USING_CUDA </span>
<a name="l00529"></a>00529 <span class="comment">    register float norm = rsqrtf(direction-&gt;x*direction-&gt;x + direction-&gt;y*direction-&gt;y + direction-&gt;z*direction-&gt;z);     // Using the GPU reciprocal sqrt function</span>
<a name="l00530"></a>00530 <span class="comment">  #else</span>
<a name="l00531"></a>00531 <span class="comment">    register float norm = 1.0f/sqrtf(direction-&gt;x*direction-&gt;x + direction-&gt;y*direction-&gt;y + direction-&gt;z*direction-&gt;z);</span>
<a name="l00532"></a>00532 <span class="comment">  #endif</span>
<a name="l00533"></a>00533 <span class="comment">  direction-&gt;x = direction-&gt;x * norm;</span>
<a name="l00534"></a>00534 <span class="comment">  direction-&gt;y = direction-&gt;y * norm;</span>
<a name="l00535"></a>00535 <span class="comment">  direction-&gt;z = direction-&gt;z * norm;</span>
<a name="l00536"></a>00536 <span class="comment">*/</span>
<a name="l00537"></a>00537 
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         <span class="comment">// // *** Sample initial direction with a cone beam:           // !!DeBuG!! Cone beam source:</span>
<a name="l00540"></a>00540         <span class="comment">//   direction-&gt;x = source_data_CONST.direction[*num_p].x;</span>
<a name="l00541"></a>00541         <span class="comment">//   direction-&gt;y = source_data_CONST.direction[*num_p].y;</span>
<a name="l00542"></a>00542         <span class="comment">//   direction-&gt;z = source_data_CONST.direction[*num_p].z;</span>
<a name="l00543"></a>00543         <span class="comment">//   // -- Rotate the current direction according to the sampled angles (using double precision!) [2*pi=6.283185307...]</span>
<a name="l00544"></a>00544         <span class="comment">//   // !!DeBuG!! the variable "tan_phi_semiaperture" is assumed to contain "cos_aperture"!! "tan_theta_semiaperture" is never used here.</span>
<a name="l00545"></a>00545         <span class="comment">//   rotate_double( direction,</span>
<a name="l00546"></a>00546         <span class="comment">//                 /*cos_theta=*/ source_data_CONST.tan_phi_semiaperture + (1.0f - source_data_CONST.tan_phi_semiaperture)*ranecu_double(seed),</span>
<a name="l00547"></a>00547         <span class="comment">//                 /*phi=*/ 6.28318530717958647693*ranecu_double(seed) );</span>
<a name="l00548"></a>00548         
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <span class="comment">// *** Move the particle inside the voxel bounding box:</span>
<a name="l00551"></a>00551 
<a name="l00552"></a>00552   <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__v1_81_8h.html#ea632931ac52bff8d7c9e9cb4e63fd7a" title="Global variable to be stored in the GPU constant memory defining the x-ray detector...">detector_data_CONST</a>.<a class="code" href="structdetector__struct.html#dbe41a01886ae097dac0fa908551d035">rotation_flag</a> != 1)   <span class="comment">// Initial directions is (0,+1,0): move the particle to the plane Y=0 and do not check any other plane for intersection</span>
<a name="l00553"></a>00553   {
<a name="l00554"></a>00554     <span class="keywordtype">float</span> dist_y = (EPS_SOURCE - <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].y) / direction-&gt;y;
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     if (dist_y &gt; 0.0)
<a name="l00557"></a>00557     {    
<a name="l00558"></a>00558       position-&gt;y  = EPS_SOURCE;      <span class="comment">// Particle will be slightly inside the voxel Y=0 border</span>
<a name="l00559"></a>00559       position-&gt;x  = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].x + dist_y*(direction-&gt;x);  <span class="comment">// Particle may be inside or outside the voxels (source may be wider than the bbox).</span>
<a name="l00560"></a>00560       position-&gt;z  = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].z + dist_y*(direction-&gt;z);
<a name="l00561"></a>00561     }
<a name="l00562"></a>00562     <span class="keywordflow">else</span>
<a name="l00563"></a>00563     {
<a name="l00564"></a>00564       <span class="comment">// Source located after the phantom??  !!DeBuG!!</span>
<a name="l00565"></a>00565       position-&gt;x  = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].x;
<a name="l00566"></a>00566       position-&gt;y  = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].y;
<a name="l00567"></a>00567       position-&gt;z  = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].z;
<a name="l00568"></a>00568     }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 
<a name="l00571"></a>00571 
<a name="l00572"></a>00572     <span class="keywordflow">if</span> ( (position-&gt;x &lt; 0.0f) || (position-&gt;x &gt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.x) ||
<a name="l00573"></a>00573          (position-&gt;y &lt; 0.0f) || (position-&gt;y &gt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.y) ||
<a name="l00574"></a>00574          (position-&gt;z &lt; 0.0f) || (position-&gt;z &gt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.z) )
<a name="l00575"></a>00575        (*absvox) = -111;  <span class="comment">// Particle not pointing to the voxel bbox: return absvox&lt;0 to skip interaction sampling.</span>
<a name="l00576"></a>00576     
<a name="l00577"></a>00577   }
<a name="l00578"></a>00578   <span class="keywordflow">else</span>    <span class="comment">// Source not pointing to (0,+1,0): check the 6 box planes for intersection</span>
<a name="l00579"></a>00579   {
<a name="l00580"></a>00580     <span class="comment">// -- Find the distance to the planes of the bbox: front or back planes depending on the sign of the movement direction vector.</span>
<a name="l00581"></a>00581     <span class="comment">//    An EPSILON distance is added to make sure the particles will be clearly inside the bbox, not on the surface.</span>
<a name="l00582"></a>00582     <span class="comment">//    Currently the source can not be located inside the bbox (particles will be moved to the edge anyway)!</span>
<a name="l00583"></a>00583     <span class="comment">//    The back lower vertex of the voxel bounding box is always located at the origin: (x0,y0,z0)=(0,0,0).</span>
<a name="l00584"></a>00584     <span class="comment">//    A negative distance means no intersection with that plane.</span>
<a name="l00585"></a>00585     <span class="keywordtype">float</span> dist_y, dist_x, dist_z;
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 
<a name="l00588"></a>00588     <span class="comment">// -Distance to the nearest Y plane:</span>
<a name="l00589"></a>00589     <span class="keywordflow">if</span> ((direction-&gt;y) &gt; EPS_SOURCE)   <span class="comment">// Moving to +Y: check distance to y=0 plane</span>
<a name="l00590"></a>00590     {
<a name="l00591"></a>00591       <span class="comment">// Check Y=0:</span>
<a name="l00592"></a>00592       <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].y &gt; 0.0f)
<a name="l00593"></a>00593         dist_y = INF;  <span class="comment">// No intersection with this plane possible: dist_y would be negative</span>
<a name="l00594"></a>00594       <span class="keywordflow">else</span>
<a name="l00595"></a>00595         dist_y = EPS_SOURCE + (-<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].y)/(direction-&gt;y);    <span class="comment">// dist_y &gt; 0 for sure in this case</span>
<a name="l00596"></a>00596     }
<a name="l00597"></a>00597     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((direction-&gt;y) &lt; NEG_EPS_SOURCE)
<a name="l00598"></a>00598     {
<a name="l00599"></a>00599       <span class="comment">// Check Y=voxel_data_CONST.size_bbox.y:</span>
<a name="l00600"></a>00600       <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].y &lt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.y)
<a name="l00601"></a>00601         dist_y = INF;  <span class="comment">// No intersection with this plane possible: dist_y would be negative</span>
<a name="l00602"></a>00602       <span class="keywordflow">else</span>
<a name="l00603"></a>00603         dist_y = EPS_SOURCE + (<a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.y - <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].y)/(direction-&gt;y);    <span class="comment">// dist_y &gt; 0 for sure in this case</span>
<a name="l00604"></a>00604     }
<a name="l00605"></a>00605     <span class="keywordflow">else</span>   <span class="comment">// (direction-&gt;y)~0</span>
<a name="l00606"></a>00606       dist_y = INF;   <span class="comment">// Particle moving parallel to the plane: considering no interaction possible (dist = INFINITE)</span>
<a name="l00607"></a>00607 
<a name="l00608"></a>00608     <span class="comment">// -Distance to the nearest X plane:</span>
<a name="l00609"></a>00609     <span class="keywordflow">if</span> ((direction-&gt;x) &gt; EPS_SOURCE)
<a name="l00610"></a>00610     {
<a name="l00611"></a>00611       <span class="comment">// Check X=0:</span>
<a name="l00612"></a>00612       <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].x &gt; 0.0f)
<a name="l00613"></a>00613         dist_x = INF;  <span class="comment">// No intersection with this plane possible: dist_x would be negative</span>
<a name="l00614"></a>00614       <span class="keywordflow">else</span>  
<a name="l00615"></a>00615         dist_x = EPS_SOURCE + (-<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].x)/(direction-&gt;x);    <span class="comment">// dist_x &gt; 0 for sure in this case</span>
<a name="l00616"></a>00616     }
<a name="l00617"></a>00617     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((direction-&gt;x) &lt; NEG_EPS_SOURCE)
<a name="l00618"></a>00618     {
<a name="l00619"></a>00619       <span class="comment">// Check X=voxel_data_CONST.size_bbox.x:</span>
<a name="l00620"></a>00620       <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].x &lt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.x)
<a name="l00621"></a>00621         dist_x = INF;  <span class="comment">// No intersection with this plane possible: dist_x would be negative</span>
<a name="l00622"></a>00622       <span class="keywordflow">else</span>  
<a name="l00623"></a>00623         dist_x = EPS_SOURCE + (<a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.x - <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].x)/(direction-&gt;x);    <span class="comment">// dist_x &gt; 0 for sure in this case</span>
<a name="l00624"></a>00624     }
<a name="l00625"></a>00625     <span class="keywordflow">else</span>
<a name="l00626"></a>00626       dist_x = INF;
<a name="l00627"></a>00627 
<a name="l00628"></a>00628     <span class="comment">// -Distance to the nearest Z plane:</span>
<a name="l00629"></a>00629     <span class="keywordflow">if</span> ((direction-&gt;z) &gt; EPS_SOURCE)
<a name="l00630"></a>00630     {
<a name="l00631"></a>00631       <span class="comment">// Check Z=0:</span>
<a name="l00632"></a>00632       <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].z &gt; 0.0f)
<a name="l00633"></a>00633         dist_z = INF;  <span class="comment">// No intersection with this plane possible: dist_z would be negative</span>
<a name="l00634"></a>00634       <span class="keywordflow">else</span>
<a name="l00635"></a>00635         dist_z = EPS_SOURCE + (-<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].z)/(direction-&gt;z);    <span class="comment">// dist_z &gt; 0 for sure in this case</span>
<a name="l00636"></a>00636     }
<a name="l00637"></a>00637     <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((direction-&gt;z) &lt; NEG_EPS_SOURCE)
<a name="l00638"></a>00638     {
<a name="l00639"></a>00639       <span class="comment">// Check Z=voxel_data_CONST.size_bbox.z:</span>
<a name="l00640"></a>00640       <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].z &lt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.z)
<a name="l00641"></a>00641         dist_z = INF;  <span class="comment">// No intersection with this plane possible: dist_z would be negative</span>
<a name="l00642"></a>00642       <span class="keywordflow">else</span>
<a name="l00643"></a>00643         dist_z = EPS_SOURCE + (<a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.z - <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].z)/(direction-&gt;z);    <span class="comment">// dist_z &gt; 0 for sure in this case</span>
<a name="l00644"></a>00644     }
<a name="l00645"></a>00645     <span class="keywordflow">else</span>
<a name="l00646"></a>00646       dist_z = INF;
<a name="l00647"></a>00647 
<a name="l00648"></a>00648 
<a name="l00649"></a>00649 <span class="comment">/*  !!DeBuG!! OLD!!</span>
<a name="l00650"></a>00650 <span class="comment">    // -Distance to the nearest Y plane:</span>
<a name="l00651"></a>00651 <span class="comment">    if ((direction-&gt;y) &gt; EPS_SOURCE)   // Moving to +Y: check distance to y=0 plane</span>
<a name="l00652"></a>00652 <span class="comment">    {</span>
<a name="l00653"></a>00653 <span class="comment">      dist_y = EPS_SOURCE + (-source_data_CONST.position[*num_p].y)/(direction-&gt;y);</span>
<a name="l00654"></a>00654 <span class="comment">      if (dist_y&lt;0.0f)</span>
<a name="l00655"></a>00655 <span class="comment">        dist_y = INF;</span>
<a name="l00656"></a>00656 <span class="comment">    }</span>
<a name="l00657"></a>00657 <span class="comment">    else if ((direction-&gt;y) &lt; NEG_EPS_SOURCE)  // Moving to -Y: check distance to y=Dy plane</span>
<a name="l00658"></a>00658 <span class="comment">    {</span>
<a name="l00659"></a>00659 <span class="comment">      dist_y = EPS_SOURCE + (voxel_data_CONST.size_bbox.y - source_data_CONST.position[*num_p].y)/(direction-&gt;y);</span>
<a name="l00660"></a>00660 <span class="comment">      if (dist_y&lt;0.0f)</span>
<a name="l00661"></a>00661 <span class="comment">        dist_y = INF;</span>
<a name="l00662"></a>00662 <span class="comment">    }</span>
<a name="l00663"></a>00663 <span class="comment">    else   // (direction-&gt;y)~0</span>
<a name="l00664"></a>00664 <span class="comment">      dist_y = INF;   // Particle moving parallel to the plane: considering no interaction possible (dist = INFINITE)</span>
<a name="l00665"></a>00665 <span class="comment"></span>
<a name="l00666"></a>00666 <span class="comment">    // -Distance to the nearest X plane:</span>
<a name="l00667"></a>00667 <span class="comment">    if ((direction-&gt;x) &gt; EPS_SOURCE)</span>
<a name="l00668"></a>00668 <span class="comment">    {</span>
<a name="l00669"></a>00669 <span class="comment">      dist_x = EPS_SOURCE + (-source_data_CONST.position[*num_p].x)/(direction-&gt;x);</span>
<a name="l00670"></a>00670 <span class="comment">      if (dist_x&lt;0.0f)</span>
<a name="l00671"></a>00671 <span class="comment">        dist_x = INF;</span>
<a name="l00672"></a>00672 <span class="comment">    }</span>
<a name="l00673"></a>00673 <span class="comment">    else if ((direction-&gt;x) &lt; NEG_EPS_SOURCE)</span>
<a name="l00674"></a>00674 <span class="comment">    {</span>
<a name="l00675"></a>00675 <span class="comment">      dist_x = EPS_SOURCE + (voxel_data_CONST.size_bbox.x - source_data_CONST.position[*num_p].x)/(direction-&gt;x);</span>
<a name="l00676"></a>00676 <span class="comment">      if (dist_x&lt;0.0f)</span>
<a name="l00677"></a>00677 <span class="comment">        dist_x = INF;</span>
<a name="l00678"></a>00678 <span class="comment">    }</span>
<a name="l00679"></a>00679 <span class="comment">    else</span>
<a name="l00680"></a>00680 <span class="comment">      dist_x = INF;</span>
<a name="l00681"></a>00681 <span class="comment"></span>
<a name="l00682"></a>00682 <span class="comment">    // -Distance to the nearest Z plane:</span>
<a name="l00683"></a>00683 <span class="comment">    if ((direction-&gt;z) &gt; EPS_SOURCE)</span>
<a name="l00684"></a>00684 <span class="comment">    {</span>
<a name="l00685"></a>00685 <span class="comment">      dist_z = EPS_SOURCE + (-source_data_CONST.position[*num_p].z)/(direction-&gt;z);</span>
<a name="l00686"></a>00686 <span class="comment">      if (dist_z&lt;0.0f)</span>
<a name="l00687"></a>00687 <span class="comment">        dist_z = INF;</span>
<a name="l00688"></a>00688 <span class="comment">    }</span>
<a name="l00689"></a>00689 <span class="comment">    else if ((direction-&gt;z) &lt; NEG_EPS_SOURCE)</span>
<a name="l00690"></a>00690 <span class="comment">    {</span>
<a name="l00691"></a>00691 <span class="comment">      dist_z = EPS_SOURCE + (voxel_data_CONST.size_bbox.z - source_data_CONST.position[*num_p].z)/(direction-&gt;z);</span>
<a name="l00692"></a>00692 <span class="comment">      if (dist_z&lt;0.0f)</span>
<a name="l00693"></a>00693 <span class="comment">        dist_z = INF;</span>
<a name="l00694"></a>00694 <span class="comment">    }</span>
<a name="l00695"></a>00695 <span class="comment">    else</span>
<a name="l00696"></a>00696 <span class="comment">      dist_z = INF;</span>
<a name="l00697"></a>00697 <span class="comment">*/</span>
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 
<a name="l00700"></a>00700     <span class="comment">// -Find the particle position inside the bbox, checking first the shortest distance planes.</span>
<a name="l00701"></a>00701     <span class="comment">//  If the particle doesn't intersect the bbox, the focal point position is returned and the main program will take care of the particle outside the voxels.</span>
<a name="l00702"></a>00702     <span class="keywordflow">for</span> (;;)   <span class="comment">// (This loop will be iterated 4 times at most, checking the 3 walls in the order of smallest distance or no intersection.)</span>
<a name="l00703"></a>00703     {
<a name="l00704"></a>00704       <span class="keywordflow">if</span> ((dist_y &lt; INF_minus1) &amp;&amp; (dist_y &lt; dist_x) &amp;&amp; (dist_y &lt;  dist_z))   <span class="comment">// Y is the shortest distance</span>
<a name="l00705"></a>00705       {
<a name="l00706"></a>00706         <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__kernel__v1_81_8cu.html#89bad1e6819d520cce606a8aa8f2cfbc" title="Evaluate if the input distance will move the particle inside the voxels or if another...">set_position</a>(num_p, &amp;dist_y, position, direction)==1)  <span class="comment">// 1 == true</span>
<a name="l00707"></a>00707           <span class="keywordflow">break</span>;   <span class="comment">// Position found inside the voxel bbox, accept it.</span>
<a name="l00708"></a>00708         <span class="keywordflow">else</span>
<a name="l00709"></a>00709           dist_y = INF;
<a name="l00710"></a>00710       }
<a name="l00711"></a>00711       <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((dist_x &lt; INF_minus1) &amp;&amp; (dist_x &lt;  dist_z))   <span class="comment">// X is the shortest distance</span>
<a name="l00712"></a>00712       {
<a name="l00713"></a>00713         <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__kernel__v1_81_8cu.html#89bad1e6819d520cce606a8aa8f2cfbc" title="Evaluate if the input distance will move the particle inside the voxels or if another...">set_position</a>(num_p, &amp;dist_x, position, direction)==1)
<a name="l00714"></a>00714           <span class="keywordflow">break</span>;
<a name="l00715"></a>00715         <span class="keywordflow">else</span>
<a name="l00716"></a>00716           dist_x = INF;
<a name="l00717"></a>00717       }
<a name="l00718"></a>00718       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dist_z &lt; INF_minus1)    <span class="comment">// Z is the shortest distance</span>
<a name="l00719"></a>00719       {
<a name="l00720"></a>00720         <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__kernel__v1_81_8cu.html#89bad1e6819d520cce606a8aa8f2cfbc" title="Evaluate if the input distance will move the particle inside the voxels or if another...">set_position</a>(num_p, &amp;dist_z, position, direction)==1)
<a name="l00721"></a>00721           <span class="keywordflow">break</span>;
<a name="l00722"></a>00722         <span class="keywordflow">else</span>
<a name="l00723"></a>00723           dist_z = INF;
<a name="l00724"></a>00724       }
<a name="l00725"></a>00725       <span class="keywordflow">else</span>
<a name="l00726"></a>00726       {
<a name="l00727"></a>00727         <span class="comment">// Particle not pointing to the voxel bbox: return focal spot position and absvox&lt;0.</span>
<a name="l00728"></a>00728         (*absvox) = -111;
<a name="l00729"></a>00729         position-&gt;x = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].x;
<a name="l00730"></a>00730         position-&gt;y = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].y;
<a name="l00731"></a>00731         position-&gt;z = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].z;
<a name="l00732"></a>00732         <span class="keywordflow">break</span>;
<a name="l00733"></a>00733       }
<a name="l00734"></a>00734     }    
<a name="l00735"></a>00735   }
<a name="l00736"></a>00736 }
<a name="l00737"></a>00737 
<a name="l00738"></a>00738 <span class="comment"></span>
<a name="l00739"></a>00739 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00740"></a>00740 <span class="comment">//! Evaluate if the input distance will move the particle inside the voxels or</span>
<a name="l00741"></a>00741 <span class="comment">//! if another distance has to be used. </span>
<a name="l00742"></a>00742 <span class="comment">//!</span>
<a name="l00743"></a>00743 <span class="comment">//!       @param[in] dist</span>
<a name="l00744"></a>00744 <span class="comment">//!       @param[in,out] position</span>
<a name="l00745"></a>00745 <span class="comment">//!       @return  1 (true) or 0 (false) integer value telling if the distance is acceptable or not.</span>
<a name="l00746"></a>00746 <span class="comment">//!</span>
<a name="l00747"></a>00747 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00748"></a>00748 <span class="comment"></span><span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00749"></a>00749 <span class="preprocessor"></span>__device__
<a name="l00750"></a>00750 <span class="preprocessor">#endif</span>
<a name="l00751"></a><a class="code" href="MC-GPU__v1_81_8h.html#89bad1e6819d520cce606a8aa8f2cfbc">00751</a> <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#89bad1e6819d520cce606a8aa8f2cfbc" title="Evaluate if the input distance will move the particle inside the voxels or if another...">set_position</a>(<span class="keywordtype">int</span>* num_p, <span class="keywordtype">float</span>* dist, float3* position, float3* direction)
<a name="l00752"></a>00752 {
<a name="l00753"></a>00753   <span class="keywordtype">int</span> acceptable = 1;
<a name="l00754"></a>00754 
<a name="l00755"></a>00755   position-&gt;x = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].x + (*dist) * direction-&gt;x;
<a name="l00756"></a>00756   <span class="keywordflow">if</span> ((position-&gt;x &lt; 0.0f) || (position-&gt;x &gt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.x))
<a name="l00757"></a>00757     acceptable = 0;  <span class="comment">// Position outside the voxels, not acceptable</span>
<a name="l00758"></a>00758   <span class="keywordflow">else</span>
<a name="l00759"></a>00759   {
<a name="l00760"></a>00760     position-&gt;y = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].y + (*dist) * direction-&gt;y;
<a name="l00761"></a>00761     <span class="keywordflow">if</span> ((position-&gt;y &lt; 0.0f) || (position-&gt;y &gt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.y))
<a name="l00762"></a>00762       acceptable = 0;
<a name="l00763"></a>00763     <span class="keywordflow">else</span>
<a name="l00764"></a>00764     {
<a name="l00765"></a>00765       position-&gt;z = <a class="code" href="MC-GPU__v1_81_8h.html#1b4da9b1f73994c4ed1aa7aafd036428" title="Global variable to be stored in the GPU constant memory defining the x-ray source...">source_data_CONST</a>.<a class="code" href="structsource__struct.html#0602793fe1b478c0ae88b22f40f20fc7">position</a>[*num_p].z + (*dist) * direction-&gt;z;
<a name="l00766"></a>00766       <span class="keywordflow">if</span> ((position-&gt;z &lt; 0.0f) || (position-&gt;z &gt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.z))
<a name="l00767"></a>00767         acceptable = 0;
<a name="l00768"></a>00768     }
<a name="l00769"></a>00769   }
<a name="l00770"></a>00770   <span class="keywordflow">return</span> acceptable;
<a name="l00771"></a>00771 }
<a name="l00772"></a>00772 
<a name="l00773"></a>00773 <span class="comment"></span>
<a name="l00774"></a>00774 <span class="comment">//!  Upper limit of the number of random values sampled in a single track.</span>
<a name="l00775"></a><a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3ab75c5bf72afd4a9b0255f61bd95704">00775</a> <span class="comment"></span><span class="preprocessor">#define  LEAP_DISTANCE     256</span><span class="comment"></span>
<a name="l00776"></a>00776 <span class="comment">//!  Multipliers and moduli for the two MLCG in RANECU.</span>
<a name="l00777"></a><a class="code" href="MC-GPU__kernel__v1_81_8cu.html#fd7d5320ad79ad99c8d230f3a730141d">00777</a> <span class="comment"></span>#define  a1_RANECU       40014
<a name="l00778"></a>00778 <span class="preprocessor">#define  m1_RANECU  2147483563</span>
<a name="l00779"></a>00779 <span class="preprocessor"></span><span class="preprocessor">#define  a2_RANECU       40692</span>
<a name="l00780"></a>00780 <span class="preprocessor"></span><span class="preprocessor">#define  m2_RANECU  2147483399</span><span class="comment"></span>
<a name="l00781"></a>00781 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00782"></a>00782 <span class="comment">//! Initialize the pseudo-random number generator (PRNG) RANECU to a position</span>
<a name="l00783"></a>00783 <span class="comment">//! far away from the previous history (leap frog technique).</span>
<a name="l00784"></a>00784 <span class="comment">//!</span>
<a name="l00785"></a>00785 <span class="comment">//! Each calculated seed initiates a consecutive and disjoint sequence of</span>
<a name="l00786"></a>00786 <span class="comment">//! pseudo-random numbers with length LEAP_DISTANCE, that can be used to</span>
<a name="l00787"></a>00787 <span class="comment">//! in a parallel simulation (Sequence Splitting parallelization method).</span>
<a name="l00788"></a>00788 <span class="comment">//! The basic equation behind the algorithm is:</span>
<a name="l00789"></a>00789 <span class="comment">//!    S(i+j) = (a**j * S(i)) MOD m = [(a**j MOD m)*S(i)] MOD m  ,</span>
<a name="l00790"></a>00790 <span class="comment">//! which is described in:</span>
<a name="l00791"></a>00791 <span class="comment">//!   P L'Ecuyer, Commun. ACM 31 (1988) p.742</span>
<a name="l00792"></a>00792 <span class="comment">//!</span>
<a name="l00793"></a>00793 <span class="comment">//! This function has been adapted from "seedsMLCG.f", see:</span>
<a name="l00794"></a>00794 <span class="comment">//!   A Badal and J Sempau, Computer Physics Communications 175 (2006) p. 440-450</span>
<a name="l00795"></a>00795 <span class="comment">//!</span>
<a name="l00796"></a>00796 <span class="comment">//!       @param[in] history   Particle bach number.</span>
<a name="l00797"></a>00797 <span class="comment">//!       @param[in] seed_input   Initial PRNG seed input (used to initiate both MLCGs in RANECU).</span>
<a name="l00798"></a>00798 <span class="comment">//!       @param[out] seed   Initial PRNG seeds for the present history.</span>
<a name="l00799"></a>00799 <span class="comment">//!</span>
<a name="l00800"></a>00800 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00801"></a>00801 <span class="comment"></span>#ifdef USING_CUDA
<a name="l00802"></a>00802 __device__
<a name="l00803"></a>00803 <span class="preprocessor">#endif</span>
<a name="l00804"></a><a class="code" href="MC-GPU__v1_81_8h.html#e7bd0b93b4d5eedb15822fa0ef622b48">00804</a> <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#e7bd0b93b4d5eedb15822fa0ef622b48" title="Initialize the pseudo-random number generator (PRNG) RANECU to a position far away...">init_PRNG</a>(<span class="keywordtype">int</span> history_batch, <span class="keywordtype">int</span> histories_per_thread, <span class="keywordtype">int</span> seed_input, int2* seed)
<a name="l00805"></a>00805 {
<a name="l00806"></a>00806   <span class="comment">// -- Move the RANECU generator to a unique position for the current batch of histories:</span>
<a name="l00807"></a>00807   <span class="comment">//    I have to use an "unsigned long long int" value to represent all the simulated histories in all previous batches</span>
<a name="l00808"></a>00808   <span class="comment">//    The maximum unsigned long long int value is ~1.8e19: if history &gt;1.8e16 and LEAP_DISTANCE==1000, 'leap' will overflow.</span>
<a name="l00809"></a>00809   <span class="comment">// **** 1st MLCG:</span>
<a name="l00810"></a>00810   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> leap = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(history_batch+1))*(histories_per_thread*<a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3ab75c5bf72afd4a9b0255f61bd95704" title="Upper limit of the number of random values sampled in a single track.">LEAP_DISTANCE</a>);
<a name="l00811"></a>00811   <span class="keywordtype">int</span> y = 1;
<a name="l00812"></a>00812   <span class="keywordtype">int</span> z = <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#fd7d5320ad79ad99c8d230f3a730141d" title="Multipliers and moduli for the two MLCG in RANECU.">a1_RANECU</a>;
<a name="l00813"></a>00813   <span class="comment">// -- Calculate the modulo power '(a^leap)MOD(m)' using a divide-and-conquer algorithm adapted to modulo arithmetic</span>
<a name="l00814"></a>00814   <span class="keywordflow">for</span>(;;)
<a name="l00815"></a>00815   {
<a name="l00816"></a>00816     <span class="comment">// (A2) Halve n, and store the integer part and the residue</span>
<a name="l00817"></a>00817     <span class="keywordflow">if</span> (0!=(leap&amp;01))  <span class="comment">// (bit-wise operation for MOD(leap,2), or leap%2 ==&gt; proceed if leap is an odd number)  Equivalent: t=(short)(leap%2);</span>
<a name="l00818"></a>00818     {
<a name="l00819"></a>00819       leap &gt;&gt;= 1;     <span class="comment">// Halve n moving the bits 1 position right. Equivalent to:  leap=(leap/2);  </span>
<a name="l00820"></a>00820       y = <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#e9061f4314474bf4415200a5cb115397" title="Calculate &amp;quot;(a1*a2) MOD m&amp;quot; with 32-bit integers and avoiding the possible...">abMODm</a>(m1_RANECU,z,y);      <span class="comment">// (A3) Multiply y by z:  y = [z*y] MOD m</span>
<a name="l00821"></a>00821       <span class="keywordflow">if</span> (0==leap) <span class="keywordflow">break</span>;         <span class="comment">// (A4) leap==0? ==&gt; finish</span>
<a name="l00822"></a>00822     }
<a name="l00823"></a>00823     <span class="keywordflow">else</span>           <span class="comment">// (leap is even)</span>
<a name="l00824"></a>00824     {
<a name="l00825"></a>00825       leap&gt;&gt;= 1;     <span class="comment">// Halve leap moving the bits 1 position right. Equivalent to:  leap=(leap/2);</span>
<a name="l00826"></a>00826     }
<a name="l00827"></a>00827     z = <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#e9061f4314474bf4415200a5cb115397" title="Calculate &amp;quot;(a1*a2) MOD m&amp;quot; with 32-bit integers and avoiding the possible...">abMODm</a>(m1_RANECU,z,z);        <span class="comment">// (A5) Square z:  z = [z*z] MOD m</span>
<a name="l00828"></a>00828   }
<a name="l00829"></a>00829   <span class="comment">// AjMODm1 = y;                 // Exponentiation finished:  AjMODm = expMOD = y = a^j</span>
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   <span class="comment">// -- Compute and display the seeds S(i+j), from the present seed S(i), using the previously calculated value of (a^j)MOD(m):</span>
<a name="l00832"></a>00832   <span class="comment">//         S(i+j) = [(a**j MOD m)*S(i)] MOD m</span>
<a name="l00833"></a>00833   <span class="comment">//         S_i = abMODm(m,S_i,AjMODm)</span>
<a name="l00834"></a>00834   seed-&gt;x = <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#e9061f4314474bf4415200a5cb115397" title="Calculate &amp;quot;(a1*a2) MOD m&amp;quot; with 32-bit integers and avoiding the possible...">abMODm</a>(m1_RANECU, seed_input, y);     <span class="comment">// Using the input seed as the starting seed</span>
<a name="l00835"></a>00835 
<a name="l00836"></a>00836   <span class="comment">// **** 2nd MLCG (repeating the previous calculation for the 2nd MLCG parameters):</span>
<a name="l00837"></a>00837   leap = ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> int)(history_batch+1))*(histories_per_thread*LEAP_DISTANCE);
<a name="l00838"></a>00838   y = 1;
<a name="l00839"></a>00839   z = a2_RANECU;
<a name="l00840"></a>00840   <span class="keywordflow">for</span>(;;)
<a name="l00841"></a>00841   {
<a name="l00842"></a>00842     <span class="comment">// (A2) Halve n, and store the integer part and the residue</span>
<a name="l00843"></a>00843     <span class="keywordflow">if</span> (0!=(leap&amp;01))  <span class="comment">// (bit-wise operation for MOD(leap,2), or leap%2 ==&gt; proceed if leap is an odd number)  Equivalent: t=(short)(leap%2);</span>
<a name="l00844"></a>00844     {
<a name="l00845"></a>00845       leap &gt;&gt;= 1;     <span class="comment">// Halve n moving the bits 1 position right. Equivalent to:  leap=(leap/2);</span>
<a name="l00846"></a>00846       y = <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#e9061f4314474bf4415200a5cb115397" title="Calculate &amp;quot;(a1*a2) MOD m&amp;quot; with 32-bit integers and avoiding the possible...">abMODm</a>(m2_RANECU,z,y);      <span class="comment">// (A3) Multiply y by z:  y = [z*y] MOD m</span>
<a name="l00847"></a>00847       <span class="keywordflow">if</span> (0==leap) <span class="keywordflow">break</span>;         <span class="comment">// (A4) leap==0? ==&gt; finish</span>
<a name="l00848"></a>00848     }
<a name="l00849"></a>00849     <span class="keywordflow">else</span>           <span class="comment">// (leap is even)</span>
<a name="l00850"></a>00850     {
<a name="l00851"></a>00851       leap&gt;&gt;= 1;     <span class="comment">// Halve leap moving the bits 1 position right. Equivalent to:  leap=(leap/2);</span>
<a name="l00852"></a>00852     }
<a name="l00853"></a>00853     z = <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#e9061f4314474bf4415200a5cb115397" title="Calculate &amp;quot;(a1*a2) MOD m&amp;quot; with 32-bit integers and avoiding the possible...">abMODm</a>(m2_RANECU,z,z);        <span class="comment">// (A5) Square z:  z = [z*z] MOD m</span>
<a name="l00854"></a>00854   }
<a name="l00855"></a>00855   <span class="comment">// AjMODm2 = y;</span>
<a name="l00856"></a>00856   seed-&gt;y = <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#e9061f4314474bf4415200a5cb115397" title="Calculate &amp;quot;(a1*a2) MOD m&amp;quot; with 32-bit integers and avoiding the possible...">abMODm</a>(m2_RANECU, seed_input, y);     <span class="comment">// Using the input seed as the starting seed</span>
<a name="l00857"></a>00857 }
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 
<a name="l00860"></a>00860 <span class="comment"></span>
<a name="l00861"></a>00861 <span class="comment">/////////////////////////////////////////////////////////////////////</span>
<a name="l00862"></a>00862 <span class="comment">//!  Calculate "(a1*a2) MOD m" with 32-bit integers and avoiding</span>
<a name="l00863"></a>00863 <span class="comment">//!  the possible overflow, using the Russian Peasant approach</span>
<a name="l00864"></a>00864 <span class="comment">//!  modulo m and the approximate factoring method, as described</span>
<a name="l00865"></a>00865 <span class="comment">//!  in:  L'Ecuyer and Cote, ACM Trans. Math. Soft. 17 (1991).</span>
<a name="l00866"></a>00866 <span class="comment">//!</span>
<a name="l00867"></a>00867 <span class="comment">//!  This function has been adapted from "seedsMLCG.f", see: </span>
<a name="l00868"></a>00868 <span class="comment">//!  Badal and Sempau, Computer Physics Communications 175 (2006)</span>
<a name="l00869"></a>00869 <span class="comment">//!</span>
<a name="l00870"></a>00870 <span class="comment">//!       @param[in] m,a,s  MLCG parameters</span>
<a name="l00871"></a>00871 <span class="comment">//!       @return   (a1*a2) MOD m   </span>
<a name="l00872"></a>00872 <span class="comment"></span><span class="comment">//</span>
<a name="l00873"></a>00873 <span class="comment">//    Input:          0 &lt; a1 &lt; m                                  </span>
<a name="l00874"></a>00874 <span class="comment">//                    0 &lt; a2 &lt; m                                  </span>
<a name="l00875"></a>00875 <span class="comment">//</span>
<a name="l00876"></a>00876 <span class="comment">//    Return value:  (a1*a2) MOD m                                </span>
<a name="l00877"></a>00877 <span class="comment">//</span><span class="comment"></span>
<a name="l00878"></a>00878 <span class="comment">/////////////////////////////////////////////////////////////////////</span>
<a name="l00879"></a>00879 <span class="comment"></span><span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00880"></a>00880 <span class="preprocessor"></span>__device__
<a name="l00881"></a>00881 <span class="preprocessor">#endif</span>
<a name="l00882"></a><a class="code" href="MC-GPU__v1_81_8h.html#e9061f4314474bf4415200a5cb115397">00882</a> <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#e9061f4314474bf4415200a5cb115397" title="Calculate &amp;quot;(a1*a2) MOD m&amp;quot; with 32-bit integers and avoiding the possible...">abMODm</a>(<span class="keywordtype">int</span> m, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> s)
<a name="l00883"></a>00883 {
<a name="l00884"></a>00884   <span class="comment">// CAUTION: the input parameters are modified in the function but should not be returned to the calling function! (pass by value!)</span>
<a name="l00885"></a>00885   <span class="keywordtype">int</span> q, k;
<a name="l00886"></a>00886   <span class="keywordtype">int</span> p = -m;            <span class="comment">// p is always negative to avoid overflow when adding</span>
<a name="l00887"></a>00887 
<a name="l00888"></a>00888   <span class="comment">// ** Apply the Russian peasant method until "a =&lt; 32768":</span>
<a name="l00889"></a>00889   <span class="keywordflow">while</span> (a&gt;32768)        <span class="comment">// We assume '32' bit integers (4 bytes): 2^(('32'-2)/2) = 32768</span>
<a name="l00890"></a>00890   {
<a name="l00891"></a>00891     <span class="keywordflow">if</span> (0!=(a&amp;1))        <span class="comment">// Store 's' when 'a' is odd     Equivalent code:   if (1==(a%2))</span>
<a name="l00892"></a>00892     {
<a name="l00893"></a>00893       p += s;
<a name="l00894"></a>00894       <span class="keywordflow">if</span> (p&gt;0) p -= m;
<a name="l00895"></a>00895     }
<a name="l00896"></a>00896     a &gt;&gt;= 1;             <span class="comment">// Half a (move bits 1 position right)   Equivalent code: a = a/2;</span>
<a name="l00897"></a>00897     s = (s-m) + s;       <span class="comment">// Double s (MOD m)</span>
<a name="l00898"></a>00898     <span class="keywordflow">if</span> (s&lt;0) s += m;     <span class="comment">// (s is always positive)</span>
<a name="l00899"></a>00899   }
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   <span class="comment">// ** Employ the approximate factoring method (a is small enough to avoid overflow):</span>
<a name="l00902"></a>00902   q = (int) m / a;
<a name="l00903"></a>00903   k = (int) s / q;
<a name="l00904"></a>00904   s = a*(s-k*q)-k*(m-q*a);
<a name="l00905"></a>00905   <span class="keywordflow">while</span> (s&lt;0)
<a name="l00906"></a>00906     s += m;
<a name="l00907"></a>00907 
<a name="l00908"></a>00908   <span class="comment">// ** Compute the final result:</span>
<a name="l00909"></a>00909   p += s;
<a name="l00910"></a>00910   <span class="keywordflow">if</span> (p&lt;0) p += m;
<a name="l00911"></a>00911 
<a name="l00912"></a>00912   <span class="keywordflow">return</span> p;
<a name="l00913"></a>00913 }
<a name="l00914"></a>00914 
<a name="l00915"></a>00915 
<a name="l00916"></a>00916 <span class="comment"></span>
<a name="l00917"></a>00917 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00918"></a>00918 <span class="comment">//! Pseudo-random number generator (PRNG) RANECU returning a float value</span>
<a name="l00919"></a>00919 <span class="comment">//! (single precision version).</span>
<a name="l00920"></a>00920 <span class="comment">//!</span>
<a name="l00921"></a>00921 <span class="comment">//!       @param[in,out] seed   PRNG seed (seed kept in the calling function and updated here).</span>
<a name="l00922"></a>00922 <span class="comment">//!       @return   PRN double value in the open interval (0,1)</span>
<a name="l00923"></a>00923 <span class="comment">//!</span>
<a name="l00924"></a>00924 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00925"></a>00925 <span class="comment"></span><span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00926"></a>00926 <span class="preprocessor"></span>__device__ 
<a name="l00927"></a>00927 <span class="preprocessor">#endif</span>
<a name="l00928"></a><a class="code" href="MC-GPU__v1_81_8h.html#3b57f2faa5765ceba5d352641ca72a9f">00928</a> <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(int2* seed)
<a name="l00929"></a>00929 {
<a name="l00930"></a>00930   <span class="keywordtype">int</span> i1 = (int)(seed-&gt;x/53668);
<a name="l00931"></a>00931   seed-&gt;x = 40014*(seed-&gt;x-i1*53668)-i1*12211;
<a name="l00932"></a>00932 
<a name="l00933"></a>00933   <span class="keywordtype">int</span> i2 = (int)(seed-&gt;y/52774);
<a name="l00934"></a>00934   seed-&gt;y = 40692*(seed-&gt;y-i2*52774)-i2*3791;
<a name="l00935"></a>00935 
<a name="l00936"></a>00936   <span class="keywordflow">if</span> (seed-&gt;x &lt; 0) seed-&gt;x += 2147483563;
<a name="l00937"></a>00937   <span class="keywordflow">if</span> (seed-&gt;y &lt; 0) seed-&gt;y += 2147483399;
<a name="l00938"></a>00938 
<a name="l00939"></a>00939   i2 = seed-&gt;x-seed-&gt;y;
<a name="l00940"></a>00940   <span class="keywordflow">if</span> (i2 &lt; 1) i2 += 2147483562;
<a name="l00941"></a>00941 
<a name="l00942"></a>00942 
<a name="l00943"></a>00943 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00944"></a>00944 <span class="preprocessor"></span>  <span class="keywordflow">return</span> (__int2float_rn(i2)*4.65661305739e-10f);        <span class="comment">// 4.65661305739e-10 == 1/2147483563</span>
<a name="l00945"></a>00945 <span class="preprocessor">#else</span>
<a name="l00946"></a>00946 <span class="preprocessor"></span>  <span class="keywordflow">return</span> ((<span class="keywordtype">float</span>)(i2)*4.65661305739e-10f);          
<a name="l00947"></a>00947 <span class="preprocessor">#endif</span>
<a name="l00948"></a>00948 <span class="preprocessor"></span>
<a name="l00949"></a>00949 }
<a name="l00950"></a>00950 
<a name="l00951"></a>00951 <span class="comment"></span>
<a name="l00952"></a>00952 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00953"></a>00953 <span class="comment">//! Pseudo-random number generator (PRNG) RANECU returning a double value.</span>
<a name="l00954"></a>00954 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00955"></a>00955 <span class="comment"></span><span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00956"></a>00956 <span class="preprocessor"></span>__device__ 
<a name="l00957"></a>00957 <span class="preprocessor">#endif</span>
<a name="l00958"></a><a class="code" href="MC-GPU__v1_81_8h.html#74c4894502584f8fb113e04b759a6c55">00958</a> <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">double</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#74c4894502584f8fb113e04b759a6c55" title="Pseudo-random number generator (PRNG) RANECU returning a double value.">ranecu_double</a>(int2* seed)
<a name="l00959"></a>00959 {
<a name="l00960"></a>00960   <span class="keywordtype">int</span> i1 = (int)(seed-&gt;x/53668);
<a name="l00961"></a>00961   seed-&gt;x = 40014*(seed-&gt;x-i1*53668)-i1*12211;
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   <span class="keywordtype">int</span> i2 = (int)(seed-&gt;y/52774);
<a name="l00964"></a>00964   seed-&gt;y = 40692*(seed-&gt;y-i2*52774)-i2*3791;
<a name="l00965"></a>00965 
<a name="l00966"></a>00966   <span class="keywordflow">if</span> (seed-&gt;x &lt; 0) seed-&gt;x += 2147483563;
<a name="l00967"></a>00967   <span class="keywordflow">if</span> (seed-&gt;y &lt; 0) seed-&gt;y += 2147483399;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969   i2 = seed-&gt;x-seed-&gt;y;
<a name="l00970"></a>00970   <span class="keywordflow">if</span> (i2 &lt; 1) i2 += 2147483562;
<a name="l00971"></a>00971 
<a name="l00972"></a>00972 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00973"></a>00973 <span class="preprocessor"></span>  <span class="keywordflow">return</span> (__int2double_rn(i2)*4.6566130573917692e-10);
<a name="l00974"></a>00974 <span class="preprocessor">#else</span>
<a name="l00975"></a>00975 <span class="preprocessor"></span>  <span class="keywordflow">return</span> ((<span class="keywordtype">double</span>)(i2)*4.6566130573917692e-10);
<a name="l00976"></a>00976 <span class="preprocessor">#endif</span>
<a name="l00977"></a>00977 <span class="preprocessor"></span>
<a name="l00978"></a>00978 }
<a name="l00979"></a>00979 
<a name="l00980"></a>00980 
<a name="l00981"></a>00981 <span class="comment"></span>
<a name="l00982"></a>00982 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00983"></a>00983 <span class="comment">//! Find the voxel that contains the current position.</span>
<a name="l00984"></a>00984 <span class="comment">//!</span>
<a name="l00985"></a>00985 <span class="comment">//!       @param[in] position   Particle position</span>
<a name="l00986"></a>00986 <span class="comment">//!       @param[in] voxel_data   Pointer to a structure containing the voxel number and size.</span>
<a name="l00987"></a>00987 <span class="comment">//!       @return   Returns "absvox", the voxel number where the particle is</span>
<a name="l00988"></a>00988 <span class="comment">//!                 located (negative if position outside the voxel bbox).</span>
<a name="l00989"></a>00989 <span class="comment">//!</span>
<a name="l00990"></a>00990 <span class="comment">////////////////////////////////////////////////////////////////////////////////</span>
<a name="l00991"></a>00991 <span class="comment"></span><span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l00992"></a>00992 <span class="preprocessor"></span>__device__
<a name="l00993"></a>00993 <span class="preprocessor">#endif</span>
<a name="l00994"></a><a class="code" href="MC-GPU__v1_81_8h.html#6ce03af860514f703cbf18f217ec1df0">00994</a> <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#6ce03af860514f703cbf18f217ec1df0" title="Find the voxel that contains the current position.">locate_voxel</a>(float3* position)
<a name="l00995"></a>00995 {
<a name="l00996"></a>00996   <span class="keywordflow">if</span> ( (position-&gt;y &lt; 0.0f) || (position-&gt;y &gt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.y) ||
<a name="l00997"></a>00997        (position-&gt;x &lt; 0.0f) || (position-&gt;x &gt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.x) ||
<a name="l00998"></a>00998        (position-&gt;z &lt; 0.0f) || (position-&gt;z &gt; <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#bdd12181cdff77da8b880eedf1d81e33">size_bbox</a>.z) )
<a name="l00999"></a>00999   {
<a name="l01000"></a>01000     <span class="comment">// -- Particle scaped the voxelized geometry:</span>
<a name="l01001"></a>01001      <span class="keywordflow">return</span> -1;
<a name="l01002"></a>01002   }   
<a name="l01003"></a>01003 
<a name="l01004"></a>01004   <span class="comment">// else</span>
<a name="l01005"></a>01005   
<a name="l01006"></a>01006     <span class="comment">// -- Particle inside the voxelized geometry, find current voxel:</span>
<a name="l01007"></a>01007 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l01008"></a>01008 <span class="preprocessor"></span>    <span class="keyword">register</span> <span class="keywordtype">int</span> voxel_coord_x = __float2int_rd(position-&gt;x * <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.x);   <span class="comment">// Using CUDA function to convert float to integer rounding down (towards minus infinite)</span>
<a name="l01009"></a>01009     <span class="keyword">register</span> <span class="keywordtype">int</span> voxel_coord_y = __float2int_rd(position-&gt;y * <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.y);
<a name="l01010"></a>01010     <span class="keyword">register</span> <span class="keywordtype">int</span> voxel_coord_z = __float2int_rd(position-&gt;z * <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.z);
<a name="l01011"></a>01011 <span class="preprocessor">#else</span>
<a name="l01012"></a>01012 <span class="preprocessor"></span>    <span class="keyword">register</span> <span class="keywordtype">int</span> voxel_coord_x = (int)(position-&gt;x * <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.x);     <span class="comment">// Truncate float to integer</span>
<a name="l01013"></a>01013     <span class="keyword">register</span> <span class="keywordtype">int</span> voxel_coord_y = (int)(position-&gt;y * <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.y);
<a name="l01014"></a>01014     <span class="keyword">register</span> <span class="keywordtype">int</span> voxel_coord_z = (int)(position-&gt;z * <a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#d1468b63b2b99455904cc43e9058d5c1">inv_voxel_size</a>.z);
<a name="l01015"></a>01015 <span class="preprocessor">#endif</span>
<a name="l01016"></a>01016 <span class="preprocessor"></span>
<a name="l01017"></a>01017 
<a name="l01018"></a>01018 <span class="comment">/* !!DeBuG!! OLD!!  ERROR in truncation for negative values!!</span>
<a name="l01019"></a>01019 <span class="comment">  int voxel_coord_y = (int)(position-&gt;y * voxel_data_CONST.inv_voxel_size.y);</span>
<a name="l01020"></a>01020 <span class="comment">  if ((voxel_coord_y&lt;0)||(voxel_coord_y&gt;=voxel_data_CONST.num_voxels.y))</span>
<a name="l01021"></a>01021 <span class="comment">    return -2;</span>
<a name="l01022"></a>01022 <span class="comment"></span>
<a name="l01023"></a>01023 <span class="comment">  int voxel_coord_z = (int)(position-&gt;z * voxel_data_CONST.inv_voxel_size.z);</span>
<a name="l01024"></a>01024 <span class="comment">  if ((voxel_coord_z&lt;0)||(voxel_coord_z&gt;=voxel_data_CONST.num_voxels.z))</span>
<a name="l01025"></a>01025 <span class="comment">    return -3;</span>
<a name="l01026"></a>01026 <span class="comment">    </span>
<a name="l01027"></a>01027 <span class="comment">  int voxel_coord_x = (int)(position-&gt;x * voxel_data_CONST.inv_voxel_size.x);</span>
<a name="l01028"></a>01028 <span class="comment">  if ((voxel_coord_x&lt;0)||(voxel_coord_x&gt;=voxel_data_CONST.num_voxels.x))</span>
<a name="l01029"></a>01029 <span class="comment">    return -1;</span>
<a name="l01030"></a>01030 <span class="comment">*/</span>
<a name="l01031"></a>01031 
<a name="l01032"></a>01032   <span class="keywordflow">return</span> (voxel_coord_x + voxel_coord_y*(<a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.x) + voxel_coord_z*(<a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.x)*(<a class="code" href="MC-GPU__v1_81_8h.html#129396d7723d11e10c673c1171773cdc" title="Global variable to be stored in the GPU constant memory defining the size of the...">voxel_data_CONST</a>.<a class="code" href="structvoxel__struct.html#deed35f7e44a7cfb2891001a1a68f868">num_voxels</a>.y));
<a name="l01033"></a>01033   
<a name="l01034"></a>01034 }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036 
<a name="l01037"></a>01037 <span class="comment"></span>
<a name="l01038"></a>01038 <span class="comment">//////////////////////////////////////////////////////////////////////</span>
<a name="l01039"></a>01039 <span class="comment">//!   Rotates a vector; the rotation is specified by giving</span>
<a name="l01040"></a>01040 <span class="comment">//!   the polar and azimuthal angles in the "self-frame", as</span>
<a name="l01041"></a>01041 <span class="comment">//!   determined by the vector to be rotated.</span>
<a name="l01042"></a>01042 <span class="comment">//!   This function is a literal translation from Fortran to C of</span>
<a name="l01043"></a>01043 <span class="comment">//!   PENELOPE (v. 2006) subroutine "DIRECT".</span>
<a name="l01044"></a>01044 <span class="comment">//!</span>
<a name="l01045"></a>01045 <span class="comment">//!    @param[in,out]  (u,v,w)  input vector (=d) in the lab. frame; returns the rotated vector components in the lab. frame</span>
<a name="l01046"></a>01046 <span class="comment">//!    @param[in]  costh  cos(theta), angle between d before and after turn</span>
<a name="l01047"></a>01047 <span class="comment">//!    @param[in]  phi  azimuthal angle (rad) turned by d in its self-frame</span>
<a name="l01048"></a>01048 <span class="comment"></span><span class="comment">//</span>
<a name="l01049"></a>01049 <span class="comment">//    Output:</span>
<a name="l01050"></a>01050 <span class="comment">//      (u,v,w) -&gt; rotated vector components in the lab. frame</span>
<a name="l01051"></a>01051 <span class="comment">//</span>
<a name="l01052"></a>01052 <span class="comment">//    Comments:</span>
<a name="l01053"></a>01053 <span class="comment">//      -&gt; (u,v,w) should have norm=1 on input; if not, it is</span>
<a name="l01054"></a>01054 <span class="comment">//         renormalized on output, provided norm&gt;0.</span>
<a name="l01055"></a>01055 <span class="comment">//      -&gt; The algorithm is based on considering the turned vector</span>
<a name="l01056"></a>01056 <span class="comment">//         d' expressed in the self-frame S',</span>
<a name="l01057"></a>01057 <span class="comment">//           d' = (sin(th)cos(ph), sin(th)sin(ph), cos(th))</span>
<a name="l01058"></a>01058 <span class="comment">//         and then apply a change of frame from S' to the lab</span>
<a name="l01059"></a>01059 <span class="comment">//         frame. S' is defined as having its z' axis coincident</span>
<a name="l01060"></a>01060 <span class="comment">//         with d, its y' axis perpendicular to z and z' and its</span>
<a name="l01061"></a>01061 <span class="comment">//         x' axis equal to y'*z'. The matrix of the change is then</span>
<a name="l01062"></a>01062 <span class="comment">//                   / uv/rho    -v/rho    u \</span>
<a name="l01063"></a>01063 <span class="comment">//          S -&gt;lab: | vw/rho     u/rho    v |  , rho=(u^2+v^2)^0.5</span>
<a name="l01064"></a>01064 <span class="comment">//                   \ -rho       0        w /</span>
<a name="l01065"></a>01065 <span class="comment">//      -&gt; When rho=0 (w=1 or -1) z and z' are parallel and the y'</span>
<a name="l01066"></a>01066 <span class="comment">//         axis cannot be defined in this way. Instead y' is set to</span>
<a name="l01067"></a>01067 <span class="comment">//         y and therefore either x'=x (if w=1) or x'=-x (w=-1)</span><span class="comment"></span>
<a name="l01068"></a>01068 <span class="comment">//////////////////////////////////////////////////////////////////////</span>
<a name="l01069"></a>01069 <span class="comment"></span><span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l01070"></a>01070 <span class="preprocessor"></span>__device__
<a name="l01071"></a>01071 <span class="preprocessor">#endif</span>
<a name="l01072"></a><a class="code" href="MC-GPU__v1_81_8h.html#cc5186c685730d287039c737445bbe43">01072</a> <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#94ad9ed794eb8fd696e7e357ae391765" title="Rotates a vector; the rotation is specified by giving the polar and azimuthal angles...">rotate_double</a>(float3* direction, <span class="keywordtype">double</span> costh, <span class="keywordtype">double</span> phi)   <span class="comment">// !!DeBuG!! The direction vector is single precision but the rotation is performed in doule precision for increased accuracy.</span>
<a name="l01073"></a>01073 {
<a name="l01074"></a>01074   <span class="keywordtype">double</span> DXY, NORM, cosphi, sinphi, SDT;
<a name="l01075"></a>01075   DXY = direction-&gt;x*direction-&gt;x + direction-&gt;y*direction-&gt;y;
<a name="l01076"></a>01076   
<a name="l01077"></a>01077 <span class="comment">//  #ifdef USING_CUDA    !!DeBuG!! sincos Also available in standard c!?</span>
<a name="l01078"></a>01078   sincos(phi, &amp;sinphi,&amp;cosphi);   <span class="comment">// Calculate the SIN and COS at the same time!</span>
<a name="l01079"></a>01079 <span class="comment">// #else</span>
<a name="l01080"></a>01080 <span class="comment">//   sinphi = sin(phi);</span>
<a name="l01081"></a>01081 <span class="comment">//   cosphi = cos(phi);</span>
<a name="l01082"></a>01082 <span class="comment">// #endif   </span>
<a name="l01083"></a>01083 
<a name="l01084"></a>01084   <span class="comment">// ****  Ensure normalisation</span>
<a name="l01085"></a>01085   NORM = DXY + direction-&gt;z*direction-&gt;z;     <span class="comment">// !!DeBuG!! Check if it is really necessary to renormalize in a real simulation!!</span>
<a name="l01086"></a>01086   <span class="keywordflow">if</span> (fabs(NORM-1.0)&gt;1.0e-14)
<a name="l01087"></a>01087   {
<a name="l01088"></a>01088     NORM = 1.0/sqrt(NORM);
<a name="l01089"></a>01089     direction-&gt;x = NORM*direction-&gt;x;
<a name="l01090"></a>01090     direction-&gt;y = NORM*direction-&gt;y;
<a name="l01091"></a>01091     direction-&gt;z = NORM*direction-&gt;z;
<a name="l01092"></a>01092     DXY = direction-&gt;x*direction-&gt;x + direction-&gt;y*direction-&gt;y;
<a name="l01093"></a>01093   }
<a name="l01094"></a>01094   <span class="keywordflow">if</span> (DXY&gt;1.0e-28)
<a name="l01095"></a>01095   {
<a name="l01096"></a>01096     SDT = sqrt((1.0-costh*costh)/DXY);
<a name="l01097"></a>01097     <span class="keywordtype">float</span> direction_x_in = direction-&gt;x;
<a name="l01098"></a>01098     direction-&gt;x = direction-&gt;x*costh + SDT*(direction_x_in*direction-&gt;z*cosphi-direction-&gt;y*sinphi);
<a name="l01099"></a>01099     direction-&gt;y = direction-&gt;y*costh+SDT*(direction-&gt;y*direction-&gt;z*cosphi+direction_x_in*sinphi);
<a name="l01100"></a>01100     direction-&gt;z = direction-&gt;z*costh-DXY*SDT*cosphi;
<a name="l01101"></a>01101   }
<a name="l01102"></a>01102   <span class="keywordflow">else</span>
<a name="l01103"></a>01103   {
<a name="l01104"></a>01104     SDT = sqrt(1.0-costh*costh);
<a name="l01105"></a>01105     direction-&gt;y = SDT*sinphi;
<a name="l01106"></a>01106     <span class="keywordflow">if</span> (direction-&gt;z&gt;0.0)
<a name="l01107"></a>01107     {
<a name="l01108"></a>01108       direction-&gt;x = SDT*cosphi;
<a name="l01109"></a>01109       direction-&gt;z = costh;
<a name="l01110"></a>01110     }
<a name="l01111"></a>01111     <span class="keywordflow">else</span>
<a name="l01112"></a>01112     {
<a name="l01113"></a>01113       direction-&gt;x =-SDT*cosphi;
<a name="l01114"></a>01114       direction-&gt;z =-costh;
<a name="l01115"></a>01115     }
<a name="l01116"></a>01116   }
<a name="l01117"></a>01117 }
<a name="l01118"></a>01118 
<a name="l01119"></a>01119 <span class="comment"></span>
<a name="l01120"></a>01120 <span class="comment">//////////////////////////////////////////////////////////////////////</span>
<a name="l01121"></a>01121 <span class="comment"></span>
<a name="l01122"></a>01122 
<a name="l01123"></a>01123 <span class="comment">//  ***********************************************************************</span>
<a name="l01124"></a>01124 <span class="comment">//  *   Translation of PENELOPE's "SUBROUTINE GRAa" from FORTRAN77 to C   *</span>
<a name="l01125"></a>01125 <span class="comment">//  ***********************************************************************</span><span class="comment"></span>
<a name="l01126"></a>01126 <span class="comment">//!  Sample a Rayleigh interaction using the sampling algorithm</span>
<a name="l01127"></a>01127 <span class="comment">//!  used in PENELOPE 2006.</span>
<a name="l01128"></a>01128 <span class="comment">//!</span>
<a name="l01129"></a>01129 <span class="comment">//!       @param[in] energy   Particle energy (not modified with Rayleigh)</span>
<a name="l01130"></a>01130 <span class="comment">//!       @param[out] costh_Rayleigh   Cosine of the angular deflection</span>
<a name="l01131"></a>01131 <span class="comment">//!       @param[in] material  Current voxel material</span>
<a name="l01132"></a>01132 <span class="comment"></span><span class="comment">//</span>
<a name="l01133"></a>01133 <span class="comment">//  CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span>
<a name="l01134"></a>01134 <span class="comment">//  C  PENELOPE/PENGEOM (version 2006)                                     C</span>
<a name="l01135"></a>01135 <span class="comment">//  C    Copyright (c) 2001-2006                                           C</span>
<a name="l01136"></a>01136 <span class="comment">//  C    Universitat de Barcelona                                          C</span>
<a name="l01137"></a>01137 <span class="comment">//  C  Permission to use, copy, modify, distribute and sell this software  C</span>
<a name="l01138"></a>01138 <span class="comment">//  C  and its documentation for any purpose is hereby granted without     C</span>
<a name="l01139"></a>01139 <span class="comment">//  C  fee, provided that the above copyright notice appears in all        C</span>
<a name="l01140"></a>01140 <span class="comment">//  C  copies and that both that copyright notice and this permission      C</span>
<a name="l01141"></a>01141 <span class="comment">//  C  notice appear in all supporting documentation. The Universitat de   C</span>
<a name="l01142"></a>01142 <span class="comment">//  C  Barcelona makes no representations about the suitability of this    C</span>
<a name="l01143"></a>01143 <span class="comment">//  C  software for any purpose. It is provided "as is" without express    C</span>
<a name="l01144"></a>01144 <span class="comment">//  C  or implied warranty.                                                C</span>
<a name="l01145"></a>01145 <span class="comment">//  CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span><span class="comment"></span>
<a name="l01146"></a>01146 <span class="comment">//////////////////////////////////////////////////////////////////////</span>
<a name="l01147"></a>01147 <span class="comment"></span><span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l01148"></a>01148 <span class="preprocessor"></span>__device__
<a name="l01149"></a>01149 <span class="preprocessor">#endif</span>
<a name="l01150"></a><a class="code" href="MC-GPU__v1_81_8h.html#5cafd4ebb3d155746b16ca7d231ecad1">01150</a> <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#5cafd4ebb3d155746b16ca7d231ecad1" title="Sample a Rayleigh interaction using the sampling algorithm used in PENELOPE 2006...">GRAa</a>(<span class="keywordtype">float</span> *energy, <span class="keywordtype">double</span> *costh_Rayleigh, <span class="keywordtype">int</span> *mat, <span class="keywordtype">float</span> *pmax_current, int2 *seed, <span class="keyword">struct</span> <a class="code" href="structrayleigh__struct.html" title="Structure storing the data of the Rayleigh interaction sampling model (equivalent...">rayleigh_struct</a>* cgra)
<a name="l01151"></a>01151 {
<a name="l01152"></a>01152 <span class="comment">/*  ****  Energy grid and interpolation constants for the current energy. */</span>
<a name="l01153"></a>01153     <span class="keywordtype">double</span>  xmax = ((double)*energy) * 8.065535669099010e-5;       <span class="comment">// 8.065535669099010e-5 == 2.0*20.6074/510998.918</span>
<a name="l01154"></a>01154     <span class="keywordtype">double</span> x2max = min_value( (xmax*xmax) , ((<span class="keywordtype">double</span>)cgra-&gt;<a class="code" href="structrayleigh__struct.html#3d91ed8dc782c166106093ae028f0dd8">xco</a>[(*mat+1)*NP_RAYLEIGH - 1]) );   <span class="comment">// Get the last tabulated value of xco for this mat</span>
<a name="l01155"></a>01155     
<a name="l01156"></a>01156     <span class="keywordflow">if</span> (xmax &lt; 0.01)
<a name="l01157"></a>01157     {
<a name="l01158"></a>01158        <span class="keywordflow">do</span>
<a name="l01159"></a>01159        {
<a name="l01160"></a>01160           *costh_Rayleigh = 1.0 - <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#74c4894502584f8fb113e04b759a6c55" title="Pseudo-random number generator (PRNG) RANECU returning a double value.">ranecu_double</a>(seed) * 2.0;
<a name="l01161"></a>01161        }
<a name="l01162"></a>01162        <span class="keywordflow">while</span> ( <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#74c4894502584f8fb113e04b759a6c55" title="Pseudo-random number generator (PRNG) RANECU returning a double value.">ranecu_double</a>(seed) &gt; (((*costh_Rayleigh)*(*costh_Rayleigh)+1.0)*0.5) );
<a name="l01163"></a>01163        <span class="keywordflow">return</span>;
<a name="l01164"></a>01164     }
<a name="l01165"></a>01165 
<a name="l01166"></a>01166     <span class="keywordflow">for</span>(;;)    <span class="comment">// (Loop will iterate everytime the sampled value is rejected or above maximum)</span>
<a name="l01167"></a>01167     {
<a name="l01168"></a>01168       <span class="keywordtype">double</span> ru = <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#74c4894502584f8fb113e04b759a6c55" title="Pseudo-random number generator (PRNG) RANECU returning a double value.">ranecu_double</a>(seed) * (double)(*pmax_current);    <span class="comment">// Pmax for the current energy is entered as a parameter</span>
<a name="l01169"></a>01169  
<a name="l01170"></a>01170 <span class="comment">/*  ****  Selection of the interval  (binary search within pre-calculated limits). */</span>
<a name="l01171"></a>01171       <span class="keywordtype">int</span> itn = (int)(ru * (NP_RAYLEIGH-1));     <span class="comment">// 'itn' will never reach the last interval 'NP_RAYLEIGH-1', but this is how RITA is implemented in PENELOPE</span>
<a name="l01172"></a>01172       <span class="keywordtype">int</span> i__ = (int)cgra-&gt;<a class="code" href="structrayleigh__struct.html#81e58bece94cd34133d55960cee9fe73">itlco</a>[itn + (*mat)*NP_RAYLEIGH];
<a name="l01173"></a>01173       <span class="keywordtype">int</span> j   = (int)cgra-&gt;<a class="code" href="structrayleigh__struct.html#f8eb91b5cbbc3bdf6d84e3aa9525946a">ituco</a>[itn + (*mat)*NP_RAYLEIGH];
<a name="l01174"></a>01174       
<a name="l01175"></a>01175       <span class="keywordflow">if</span> ((j - i__) &gt; 1)
<a name="l01176"></a>01176       {
<a name="l01177"></a>01177         <span class="keywordflow">do</span>
<a name="l01178"></a>01178         {
<a name="l01179"></a>01179           <span class="keyword">register</span> <span class="keywordtype">int</span> k = (i__ + j)&gt;&gt;1;     <span class="comment">// &gt;&gt;1 == /2 </span>
<a name="l01180"></a>01180           <span class="keywordflow">if</span> (ru &gt; cgra-&gt;<a class="code" href="structrayleigh__struct.html#85ba59a95287c8d2ec3895b9ea6f8f43">pco</a>[k -1 + (*mat)*NP_RAYLEIGH])
<a name="l01181"></a>01181             i__ = k;
<a name="l01182"></a>01182           <span class="keywordflow">else</span>
<a name="l01183"></a>01183             j = k;
<a name="l01184"></a>01184         }
<a name="l01185"></a>01185         <span class="keywordflow">while</span> ((j - i__) &gt; 1);
<a name="l01186"></a>01186       }
<a name="l01187"></a>01187        
<a name="l01188"></a>01188 <span class="comment">/*  ****  Sampling from the rational inverse cumulative distribution. */</span>
<a name="l01189"></a>01189       <span class="keywordtype">int</span> index = i__ - 1 + (*mat)*NP_RAYLEIGH;
<a name="l01190"></a>01190 
<a name="l01191"></a>01191       <span class="keywordtype">double</span> rr = ru - cgra-&gt;<a class="code" href="structrayleigh__struct.html#85ba59a95287c8d2ec3895b9ea6f8f43">pco</a>[index];
<a name="l01192"></a>01192       <span class="keywordtype">double</span> xx;
<a name="l01193"></a>01193       <span class="keywordflow">if</span> (rr &gt; 1e-16)
<a name="l01194"></a>01194       {      
<a name="l01195"></a>01195         <span class="keywordtype">double</span> d__ = (double)(cgra-&gt;<a class="code" href="structrayleigh__struct.html#85ba59a95287c8d2ec3895b9ea6f8f43">pco</a>[index+1] - cgra-&gt;<a class="code" href="structrayleigh__struct.html#85ba59a95287c8d2ec3895b9ea6f8f43">pco</a>[index]);
<a name="l01196"></a>01196         <span class="keywordtype">float</span> aco_index = cgra-&gt;<a class="code" href="structrayleigh__struct.html#2ea1b62a4e4cc5900c060fed2d95fec5">aco</a>[index], bco_index = cgra-&gt;<a class="code" href="structrayleigh__struct.html#f107a7fbdd989e049ba67b9fc2e614c3">bco</a>[index], xco_index = cgra-&gt;<a class="code" href="structrayleigh__struct.html#3d91ed8dc782c166106093ae028f0dd8">xco</a>[index];   <span class="comment">// Avoid multiple accesses to the same global variable</span>
<a name="l01197"></a>01197 
<a name="l01198"></a>01198         xx = (double)xco_index + (<span class="keywordtype">double</span>)(aco_index + 1.0f + bco_index)* d__* rr / (d__*d__ + (aco_index*d__ + bco_index*rr) * rr) * (<span class="keywordtype">double</span>)(cgra-&gt;<a class="code" href="structrayleigh__struct.html#3d91ed8dc782c166106093ae028f0dd8">xco</a>[index+1] - xco_index);
<a name="l01199"></a>01199         
<a name="l01200"></a>01200       }
<a name="l01201"></a>01201       <span class="keywordflow">else</span>
<a name="l01202"></a>01202       {
<a name="l01203"></a>01203         xx = cgra-&gt;<a class="code" href="structrayleigh__struct.html#3d91ed8dc782c166106093ae028f0dd8">xco</a>[index];
<a name="l01204"></a>01204       }
<a name="l01205"></a>01205       
<a name="l01206"></a>01206       <span class="keywordflow">if</span> (xx &lt; x2max)
<a name="l01207"></a>01207       {
<a name="l01208"></a>01208         <span class="comment">// Sampled value below maximum possible value:</span>
<a name="l01209"></a>01209         *costh_Rayleigh = 1.0 - 2.0 * xx / x2max;   <span class="comment">// !!DeBuG!! costh_Rayleigh in double precision, but not all intermediate steps are!?</span>
<a name="l01210"></a>01210         <span class="comment">/*  ****  Rejection: */</span>    
<a name="l01211"></a>01211         <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__kernel__v1_81_8cu.html#74c4894502584f8fb113e04b759a6c55" title="Pseudo-random number generator (PRNG) RANECU returning a double value.">ranecu_double</a>(seed) &lt; (((*costh_Rayleigh)*(*costh_Rayleigh) + 1.0)*0.5))
<a name="l01212"></a>01212           <span class="keywordflow">break</span>;   <span class="comment">// Sample value not rejected! break loop and return.</span>
<a name="l01213"></a>01213       }
<a name="l01214"></a>01214     }
<a name="l01215"></a>01215 } <span class="comment">/* graa */</span>
<a name="l01216"></a>01216 
<a name="l01217"></a>01217 
<a name="l01218"></a>01218 <span class="comment"></span>
<a name="l01219"></a>01219 <span class="comment">//////////////////////////////////////////////////////////////////////////</span>
<a name="l01220"></a>01220 <span class="comment"></span>
<a name="l01221"></a>01221 
<a name="l01222"></a>01222 <span class="comment">//  ***********************************************************************</span>
<a name="l01223"></a>01223 <span class="comment">//  *   Translation of PENELOPE's "SUBROUTINE GCOa"  from FORTRAN77 to C  *</span>
<a name="l01224"></a>01224 <span class="comment">//  ********************************************************************* *</span><span class="comment"></span>
<a name="l01225"></a>01225 <span class="comment">//!  Random sampling of incoherent (Compton) scattering of photons, using </span>
<a name="l01226"></a>01226 <span class="comment">//!  the sampling algorithm from PENELOPE 2006:</span>
<a name="l01227"></a>01227 <span class="comment">//!    Relativistic impulse approximation with analytical one-electron Compton profiles</span>
<a name="l01228"></a>01228 <span class="comment"></span>
<a name="l01229"></a>01229 <span class="comment">// !!DeBuG!!  In penelope, Doppler broadening is not used for E greater than 5 MeV.</span>
<a name="l01230"></a>01230 <span class="comment">//            We don't use it in GPU to reduce the lines of code and prevent using COMMON/compos/ZT(M)</span>
<a name="l01231"></a>01231 <span class="comment"></span>
<a name="l01232"></a>01232 <span class="comment">//!       @param[in,out] energy   incident and final photon energy (eV)</span>
<a name="l01233"></a>01233 <span class="comment">//!       @param[out] costh_Compton   cosine of the polar scattering angle</span>
<a name="l01234"></a>01234 <span class="comment">//!       @param[in] material   Current voxel material</span>
<a name="l01235"></a>01235 <span class="comment">//!       @param[in] seed   RANECU PRNG seed</span>
<a name="l01236"></a>01236 <span class="comment"></span><span class="comment">//</span>
<a name="l01237"></a>01237 <span class="comment">//  CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span>
<a name="l01238"></a>01238 <span class="comment">//  C  PENELOPE/PENGEOM (version 2006)                                     C</span>
<a name="l01239"></a>01239 <span class="comment">//  C    Copyright (c) 2001-2006                                           C</span>
<a name="l01240"></a>01240 <span class="comment">//  C    Universitat de Barcelona                                          C</span>
<a name="l01241"></a>01241 <span class="comment">//  C  Permission to use, copy, modify, distribute and sell this software  C</span>
<a name="l01242"></a>01242 <span class="comment">//  C  and its documentation for any purpose is hereby granted without     C</span>
<a name="l01243"></a>01243 <span class="comment">//  C  fee, provided that the above copyright notice appears in all        C</span>
<a name="l01244"></a>01244 <span class="comment">//  C  copies and that both that copyright notice and this permission      C</span>
<a name="l01245"></a>01245 <span class="comment">//  C  notice appear in all supporting documentation. The Universitat de   C</span>
<a name="l01246"></a>01246 <span class="comment">//  C  Barcelona makes no representations about the suitability of this    C</span>
<a name="l01247"></a>01247 <span class="comment">//  C  software for any purpose. It is provided "as is" without express    C</span>
<a name="l01248"></a>01248 <span class="comment">//  C  or implied warranty.                                                C</span>
<a name="l01249"></a>01249 <span class="comment">//  CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</span>
<a name="l01250"></a>01250 <span class="comment">//</span>
<a name="l01251"></a>01251 <span class="comment">//  ************************************************************************</span>
<a name="l01252"></a>01252 
<a name="l01253"></a>01253 <span class="preprocessor">#ifdef USING_CUDA</span>
<a name="l01254"></a>01254 <span class="preprocessor"></span>__device__
<a name="l01255"></a>01255 <span class="preprocessor">#endif</span>
<a name="l01256"></a><a class="code" href="MC-GPU__v1_81_8h.html#6f212862e7fba1553ec9495f05443b2c">01256</a> <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#6f212862e7fba1553ec9495f05443b2c" title="Random sampling of incoherent (Compton) scattering of photons, using the sampling...">GCOa</a>(<span class="keywordtype">float</span> *energy, <span class="keywordtype">double</span> *costh_Compton, <span class="keywordtype">int</span> *mat, int2 *seed, <span class="keyword">struct</span> <a class="code" href="structcompton__struct.html" title="Structure storing the data of the Compton interaction sampling model (equivalent...">compton_struct</a>* cgco_SHARED)
<a name="l01257"></a>01257 {
<a name="l01258"></a>01258     <span class="keywordtype">float</span> s, a1, s0, af, ek, ek2, ek3, tau, pzomc, taumin;
<a name="l01259"></a>01259     <span class="keywordtype">float</span> rn[MAX_SHELLS];
<a name="l01260"></a>01260     <span class="keywordtype">double</span> cdt1;
<a name="l01261"></a>01261 
<a name="l01262"></a>01262      <span class="comment">// Some variables used in PENELOPE have been eliminated to save register: float aux, taum2, fpzmax, a, a2, ek1 ,rni, xqc, fpz, pac[MAX_SHELLS];</span>
<a name="l01263"></a>01263 
<a name="l01264"></a>01264     <span class="keywordtype">int</span> i__;
<a name="l01265"></a>01265     <span class="keywordtype">int</span> my_noscco = cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#ef81eb007c90d13552ea867912f0d2c3">noscco</a>[*mat];    <span class="comment">// Store the number of oscillators for the input material in a local variable</span>
<a name="l01266"></a>01266 
<a name="l01267"></a>01267     ek = *energy * 1.956951306108245e-6f;    <span class="comment">// (1.956951306108245e-6 == 1.0/510998.918)</span>
<a name="l01268"></a>01268     ek2 = ek * 2.f + 1.f;
<a name="l01269"></a>01269     ek3 = ek * ek;
<a name="l01270"></a>01270     <span class="comment">// ek1 = ek3 - ek2 - 1.;</span>
<a name="l01271"></a>01271     taumin = 1.f / ek2;
<a name="l01272"></a>01272     <span class="comment">// taum2 = taumin * taumin;</span>
<a name="l01273"></a>01273     a1 = logf(ek2);
<a name="l01274"></a>01274     <span class="comment">// a2 = a1 + ek * 2. * (ek + 1.) * taum2;    // a2 was used only once, code moved below  !!DeBuG!!</span>
<a name="l01275"></a>01275 
<a name="l01276"></a>01276 
<a name="l01277"></a>01277 <span class="comment">/*  ****  Incoherent scattering function for theta=PI. */</span>
<a name="l01278"></a>01278 
<a name="l01279"></a>01279     s0 = 0.0f;
<a name="l01280"></a>01280     <span class="keywordflow">for</span> (i__ = 0; i__ &lt; my_noscco; i__++)
<a name="l01281"></a>01281     {
<a name="l01282"></a>01282        <span class="keyword">register</span> <span class="keywordtype">float</span> temp = cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#32dcebc4af75e0620abed9c32ffc2bdd">uico</a>[*mat + i__*<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>];
<a name="l01283"></a>01283        <span class="keywordflow">if</span> (temp &lt; *energy)
<a name="l01284"></a>01284        {
<a name="l01285"></a>01285          <span class="keyword">register</span> <span class="keywordtype">float</span> aux = *energy * (*energy - temp) * 2.f;
<a name="l01286"></a>01286 <span class="preprocessor">         #ifdef USING_CUDA</span>
<a name="l01287"></a>01287 <span class="preprocessor"></span>           pzomc = cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#2acdfc304123cea06abea723b5b28d38">fj0</a>[*mat + i__*<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>] * (aux - temp * 510998.918f) * rsqrtf(aux + aux + temp * temp) * 1.956951306108245e-6f;
<a name="l01288"></a>01288              <span class="comment">// 1.956951306108245e-6 = 1.0/510998.918f   // !!DeBuG!! Version using the reciprocal of sqrt in CUDA: faster and more accurate!!</span>
<a name="l01289"></a>01289 <span class="preprocessor">         #else</span>
<a name="l01290"></a>01290 <span class="preprocessor"></span>           pzomc = cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#2acdfc304123cea06abea723b5b28d38">fj0</a>[*mat + i__*<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>] * (aux - temp * 510998.918f) / (sqrtf(aux + aux + temp * temp) * 510998.918f);
<a name="l01291"></a>01291 <span class="preprocessor">         #endif</span>
<a name="l01292"></a>01292 <span class="preprocessor"></span>         <span class="keywordflow">if</span> (pzomc &gt; 0.0f)
<a name="l01293"></a>01293            temp = (0.707106781186545f+pzomc*1.4142135623731f) * (0.707106781186545f+pzomc*1.4142135623731f);
<a name="l01294"></a>01294          <span class="keywordflow">else</span>
<a name="l01295"></a>01295            temp = (0.707106781186545f-pzomc*1.4142135623731f) * (0.707106781186545f-pzomc*1.4142135623731f);
<a name="l01296"></a>01296 
<a name="l01297"></a>01297          temp = 0.5f * expf(0.5f - temp);    <span class="comment">// Calculate EXP outside the IF to avoid branching</span>
<a name="l01298"></a>01298 
<a name="l01299"></a>01299          <span class="keywordflow">if</span> (pzomc &gt; 0.0f)
<a name="l01300"></a>01300             temp = 1.0f - temp;
<a name="l01301"></a>01301                                 
<a name="l01302"></a>01302          s0 += cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#181131326c64f04da9eb7f199604371e">fco</a>[*mat + i__*<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>] * temp;
<a name="l01303"></a>01303        }
<a name="l01304"></a>01304     }
<a name="l01305"></a>01305             
<a name="l01306"></a>01306 <span class="comment">/*  ****  Sampling tau. */</span>
<a name="l01307"></a>01307     <span class="keywordflow">do</span>
<a name="l01308"></a>01308     {
<a name="l01309"></a>01309       <span class="keywordflow">if</span> (<a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(seed)*<span class="comment">/*a2=*/</span>(a1+2.*ek*(ek+1.f)*taumin*taumin) &lt; a1)
<a name="l01310"></a>01310       { 
<a name="l01311"></a>01311         tau = powf(taumin, <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(seed));    <span class="comment">// !!DeBuG!!  "powf()" has a big error (7 ULP), the double version has only 2!! !!DeBuG!!</span>
<a name="l01312"></a>01312       }
<a name="l01313"></a>01313       <span class="keywordflow">else</span>
<a name="l01314"></a>01314       {
<a name="l01315"></a>01315         tau = sqrtf(1.f + <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(seed) * (taumin * taumin - 1.f));
<a name="l01316"></a>01316       }
<a name="l01317"></a>01317 
<a name="l01318"></a>01318       cdt1 = (double)(1.f-tau) / (((double)tau)*((double)*energy)*1.956951306108245e-6);    <span class="comment">// !!DeBuG!! The sampled COS will be double precision, but TAU is not!!!</span>
<a name="l01319"></a>01319 
<a name="l01320"></a>01320       <span class="keywordflow">if</span> (cdt1 &gt; 2.0) cdt1 = 1.99999999999;   <span class="comment">// !!DeBuG!! Make sure that precision error in POW, SQRT never gives cdt1&gt;2 ==&gt; costh_Compton&lt;-1</span>
<a name="l01321"></a>01321       
<a name="l01322"></a>01322   <span class="comment">/*  ****  Incoherent scattering function. */</span>
<a name="l01323"></a>01323       s = 0.0f;
<a name="l01324"></a>01324       <span class="keywordflow">for</span> (i__ = 0; i__ &lt; my_noscco; i__++)
<a name="l01325"></a>01325       {
<a name="l01326"></a>01326         <span class="keyword">register</span> <span class="keywordtype">float</span> temp = cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#32dcebc4af75e0620abed9c32ffc2bdd">uico</a>[*mat + i__*<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>];
<a name="l01327"></a>01327         <span class="keywordflow">if</span> (temp &lt; *energy)
<a name="l01328"></a>01328         {
<a name="l01329"></a>01329           <span class="keyword">register</span> <span class="keywordtype">float</span> aux = (*energy) * (*energy - temp) * ((<span class="keywordtype">float</span>)cdt1);
<a name="l01330"></a>01330 
<a name="l01331"></a>01331           <span class="keywordflow">if</span> ((aux&gt;1.0e-12f)||(temp&gt;1.0e-12f))  <span class="comment">// !!DeBuG!! Make sure the SQRT argument is never &lt;0, and that we never get 0/0 -&gt; NaN when aux=temp=0 !!</span>
<a name="l01332"></a>01332           {
<a name="l01333"></a>01333 <span class="preprocessor">         #ifdef USING_CUDA</span>
<a name="l01334"></a>01334 <span class="preprocessor"></span>           pzomc = cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#2acdfc304123cea06abea723b5b28d38">fj0</a>[*mat + i__*<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>] * (aux - temp * 510998.918f) * rsqrtf(aux + aux + temp * temp) * 1.956951306108245e-6f;
<a name="l01335"></a>01335              <span class="comment">// 1.956951306108245e-6 = 1.0/510998.918f   // !!DeBuG!! Version using the reciprocal of sqrt in CUDA: faster and more accurate!!</span>
<a name="l01336"></a>01336 <span class="preprocessor">         #else</span>
<a name="l01337"></a>01337 <span class="preprocessor"></span>           pzomc = cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#2acdfc304123cea06abea723b5b28d38">fj0</a>[*mat + i__*<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>] * (aux - temp * 510998.918f) / (sqrtf(aux + aux + temp * temp) * 510998.918f);
<a name="l01338"></a>01338 <span class="preprocessor">         #endif</span>
<a name="l01339"></a>01339 <span class="preprocessor"></span>
<a name="l01340"></a>01340           }
<a name="l01341"></a>01341           <span class="keywordflow">else</span>
<a name="l01342"></a>01342           {
<a name="l01343"></a>01343             pzomc = 0.002f;    <span class="comment">// !!DeBuG!! Using a rough approximation to a sample value of pzomc found using pure double precision: NOT RIGUROUS! But this code is expected to be used very seldom, only in extrem cases.</span>
<a name="l01344"></a>01344 <span class="preprocessor">#ifndef USING_CUDA</span>
<a name="l01345"></a>01345 <span class="preprocessor"></span>               printf(<span class="stringliteral">" ---WARNING GCOa (1)!! i__=%d, aux=%.14f, temp=%.14f, _forced_ pzomc=%.14f, uico=%.14f, energy=%.14f, cgco_SHARED-&gt;fj0=%.14f, mat=%d, cdt1=%.14f\n"</span>, (<span class="keywordtype">int</span>)i__, aux, temp, pzomc, cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#32dcebc4af75e0620abed9c32ffc2bdd">uico</a>[*mat+i__*<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>], *energy, cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#2acdfc304123cea06abea723b5b28d38">fj0</a>[*mat+i__*MAX_MATERIALS], (<span class="keywordtype">int</span>)*mat, cdt1);   <span class="comment">// !!DeBuG!!</span>
<a name="l01346"></a>01346 <span class="preprocessor">#endif                    </span>
<a name="l01347"></a>01347 <span class="preprocessor"></span>          }
<a name="l01348"></a>01348           
<a name="l01349"></a>01349           temp = pzomc * 1.4142135623731f;
<a name="l01350"></a>01350           <span class="keywordflow">if</span> (pzomc &gt; 0.0f)
<a name="l01351"></a>01351             temp = 0.5f - (temp + 0.70710678118654502f) * (temp + 0.70710678118654502f);   <span class="comment">// Calculate exponential argument</span>
<a name="l01352"></a>01352           <span class="keywordflow">else</span>
<a name="l01353"></a>01353             temp = 0.5f - (0.70710678118654502f - temp) * (0.70710678118654502f - temp);
<a name="l01354"></a>01354 
<a name="l01355"></a>01355           temp = 0.5f * expf(temp);      <span class="comment">// All threads will calculate the expf together</span>
<a name="l01356"></a>01356           
<a name="l01357"></a>01357           <span class="keywordflow">if</span> (pzomc &gt; 0.0f)
<a name="l01358"></a>01358             temp = 1.0f - temp;
<a name="l01359"></a>01359 
<a name="l01360"></a>01360           s += cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#181131326c64f04da9eb7f199604371e">fco</a>[*mat + i__*<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>] * temp;
<a name="l01361"></a>01361           rn[i__] = temp;
<a name="l01362"></a>01362         }        
<a name="l01363"></a>01363       }
<a name="l01364"></a>01364     } <span class="keywordflow">while</span>( (<a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(seed)*s0) &gt; (s*(1.0f+tau*(<span class="comment">/*ek1=*/</span>(ek3 - ek2 - 1.0f)+tau*(ek2+tau*ek3)))/(ek3*tau*(tau*tau+1.0f))) );  <span class="comment">//  ****  Rejection function</span>
<a name="l01365"></a>01365 
<a name="l01366"></a>01366     *costh_Compton = 1.0 - cdt1;
<a name="l01367"></a>01367         
<a name="l01368"></a>01368 <span class="comment">/*  ****  Target electron shell. */</span>
<a name="l01369"></a>01369     <span class="keywordflow">for</span> (;;)
<a name="l01370"></a>01370     {
<a name="l01371"></a>01371       <span class="keyword">register</span> <span class="keywordtype">float</span> temp = s*<a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(seed);
<a name="l01372"></a>01372       <span class="keywordtype">float</span> pac = 0.0f;
<a name="l01373"></a>01373 
<a name="l01374"></a>01374       <span class="keywordtype">int</span> ishell = my_noscco - 1;     <span class="comment">// First shell will have number 0</span>
<a name="l01375"></a>01375       <span class="keywordflow">for</span> (i__ = 0; i__ &lt; (my_noscco-1); i__++)    <span class="comment">// !!DeBuG!! Iterate to (my_noscco-1) only: the last oscillator is excited in case all other fail (no point in double checking) ??</span>
<a name="l01376"></a>01376       {
<a name="l01377"></a>01377         pac += cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#181131326c64f04da9eb7f199604371e">fco</a>[*mat + i__*<a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>] * rn[i__];   <span class="comment">// !!DeBuG!! pac[] is calculated on the fly to save registers!</span>
<a name="l01378"></a>01378         <span class="keywordflow">if</span> (pac &gt; temp)       <span class="comment">//  pac[] is calculated on the fly to save registers!  </span>
<a name="l01379"></a>01379         {
<a name="l01380"></a>01380             ishell = i__;
<a name="l01381"></a>01381             <span class="keywordflow">break</span>;
<a name="l01382"></a>01382         }
<a name="l01383"></a>01383       }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385     <span class="comment">/*  ****  Projected momentum of the target electron. */</span>
<a name="l01386"></a>01386       temp = <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(seed) * rn[ishell];
<a name="l01387"></a>01387 
<a name="l01388"></a>01388       <span class="keywordflow">if</span> (temp &lt; 0.5f)
<a name="l01389"></a>01389       {
<a name="l01390"></a>01390         pzomc = (0.70710678118654502f - sqrtf(0.5f - logf(temp + temp))) / (cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#2acdfc304123cea06abea723b5b28d38">fj0</a>[*mat + ishell * <a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>] * 1.4142135623731f);
<a name="l01391"></a>01391       }
<a name="l01392"></a>01392       <span class="keywordflow">else</span>
<a name="l01393"></a>01393       {
<a name="l01394"></a>01394         pzomc = (sqrtf(0.5f - logf(2.0f - 2.0f*temp)) - 0.70710678118654502f) / (cgco_SHARED-&gt;<a class="code" href="structcompton__struct.html#2acdfc304123cea06abea723b5b28d38">fj0</a>[*mat + ishell * <a class="code" href="MC-GPU__v1_81_8h.html#7aa308231ff3dcfd43ac19023e2e6e15" title="Constants values for the Compton and Rayleigh models:.">MAX_MATERIALS</a>] * 1.4142135623731f);
<a name="l01395"></a>01395       }
<a name="l01396"></a>01396       <span class="keywordflow">if</span> (pzomc &lt; -1.0f)
<a name="l01397"></a>01397       {
<a name="l01398"></a>01398         <span class="keywordflow">continue</span>;      <span class="comment">// re-start the loop</span>
<a name="l01399"></a>01399       }
<a name="l01400"></a>01400 
<a name="l01401"></a>01401   <span class="comment">/*  ****  F(EP) rejection. */</span>
<a name="l01402"></a>01402       temp = tau * (tau - (*costh_Compton) * 2.f) + 1.f;       <span class="comment">// this variable was originally called "xqc"</span>
<a name="l01403"></a>01403       
<a name="l01404"></a>01404         <span class="comment">// af = sqrt( max_value(temp,1.0e-30f) ) * (tau * (tau - *costh_Compton) / max_value(temp,1.0e-30f) + 1.f);  //!!DeBuG!! Make sure the SQRT argument is never &lt;0, and that I don't divide by zero!!</span>
<a name="l01405"></a>01405 
<a name="l01406"></a>01406       <span class="keywordflow">if</span> (temp&gt;1.0e-20f)   <span class="comment">// !!DeBuG!! Make sure the SQRT argument is never &lt;0, and that I don't divide by zero!!</span>
<a name="l01407"></a>01407       {
<a name="l01408"></a>01408         af = sqrtf(temp) * (tau * (tau - ((float)(*costh_Compton))) / temp + 1.f);
<a name="l01409"></a>01409       }
<a name="l01410"></a>01410       <span class="keywordflow">else</span>
<a name="l01411"></a>01411       {
<a name="l01412"></a>01412         <span class="comment">// When using single precision, it is possible (but very uncommon) to get costh_Compton==1 and tau==1; then temp is 0 and 'af' can not be calculated (0/0 -&gt; nan). Analysing the results obtained using double precision, we found that 'af' would be almost 0 in this situation, with an "average" about ~0.002 (this is just a rough estimation, but using af=0 the value would never be rejected below).</span>
<a name="l01413"></a>01413 
<a name="l01414"></a>01414         af = 0.00200f;    <span class="comment">// !!DeBuG!!    // !!DeBuG!!</span>
<a name="l01415"></a>01415                 
<a name="l01416"></a>01416 <span class="preprocessor">#ifndef USING_CUDA</span>
<a name="l01417"></a>01417 <span class="preprocessor"></span>        printf(<span class="stringliteral">" ---WARNING GCOa (2)!! temp=%.14f, _forced_ af=%.14f, tau=%.14f, costh_Compton=%.14f \n"</span>, temp, af, tau, *costh_Compton);    <span class="comment">// !!DeBuG!!</span>
<a name="l01418"></a>01418 <span class="preprocessor">#endif</span>
<a name="l01419"></a>01419 <span class="preprocessor"></span>      }
<a name="l01420"></a>01420 
<a name="l01421"></a>01421       <span class="keywordflow">if</span> (af &gt; 0.0f)
<a name="l01422"></a>01422       {
<a name="l01423"></a>01423         temp = af * 0.2f + 1.f;    <span class="comment">// this variable was originally called "fpzmax"</span>
<a name="l01424"></a>01424       }
<a name="l01425"></a>01425       <span class="keywordflow">else</span>
<a name="l01426"></a>01426       {
<a name="l01427"></a>01427         temp = 1.f - af * 0.2f;
<a name="l01428"></a>01428       }
<a name="l01429"></a>01429       
<a name="l01430"></a>01430       <span class="keywordflow">if</span> ( <a class="code" href="MC-GPU__kernel__v1_81_8cu.html#3b57f2faa5765ceba5d352641ca72a9f" title="Pseudo-random number generator (PRNG) RANECU returning a float value (single precision...">ranecu</a>(seed)*temp &lt; <span class="comment">/*fpz =*/</span>(af * <a class="code" href="MC-GPU__v1_81_8h.html#1b7b63b09e6ac252980467701bd80cb7" title="Preprocessor macro to calculate maximum and minimum values:.">max_value</a>( min_value(pzomc,0.2f) , -0.2f ) + 1.f) )
<a name="l01431"></a>01431       {
<a name="l01432"></a>01432         <span class="keywordflow">break</span>;
<a name="l01433"></a>01433       }
<a name="l01434"></a>01434 
<a name="l01435"></a>01435     }
<a name="l01436"></a>01436 
<a name="l01437"></a>01437 <span class="comment">/*  ****  Energy of the scattered photon. */</span>
<a name="l01438"></a>01438     {
<a name="l01439"></a>01439       <span class="keyword">register</span> <span class="keywordtype">float</span> t, b1, b2, temp;
<a name="l01440"></a>01440       t = pzomc * pzomc;
<a name="l01441"></a>01441       b1 = 1.f - t * tau * tau;
<a name="l01442"></a>01442       b2 = 1.f - t * tau * ((float)(*costh_Compton));
<a name="l01443"></a>01443 
<a name="l01444"></a>01444       temp = sqrtf( fabsf(b2 * b2 - b1 * (1.0f - t)) );
<a name="l01445"></a>01445       
<a name="l01446"></a>01446           
<a name="l01447"></a>01447       <span class="keywordflow">if</span> (pzomc &lt; 0.0f)
<a name="l01448"></a>01448          temp *= -1.0f;
<a name="l01449"></a>01449 
<a name="l01450"></a>01450       <span class="comment">// !Error! energy may increase (slightly) due to inacurate calculation!  !!DeBuG!!</span>
<a name="l01451"></a>01451       t = (tau / b1) * (b2 + temp);
<a name="l01452"></a>01452       <span class="keywordflow">if</span> (t &gt; 1.0f)
<a name="l01453"></a>01453       {
<a name="l01454"></a>01454 <span class="preprocessor">        #ifndef USING_CUDA</span>
<a name="l01455"></a>01455 <span class="preprocessor"></span>          printf(<span class="stringliteral">" --- WARNING GCOa: Compton event tried to increase the x ray energy due to precision error!! Keep initial energy.\n  scaling=%.14f, costh_Compton=%.14lf\n"</span>, t, *costh_Compton);   <span class="comment">// !!DeBuG!!</span>
<a name="l01456"></a>01456 <span class="preprocessor">        #endif      </span>
<a name="l01457"></a>01457 <span class="preprocessor"></span>        t = 1.0f; <span class="comment">// !!DeBuG!! // !!DeBuG!! Avoid increasing energy by hand!!! not nice!!</span>
<a name="l01458"></a>01458       }
<a name="l01459"></a>01459 
<a name="l01460"></a>01460       (*energy) *= t;
<a name="l01461"></a>01461        <span class="comment">// (*energy) *= (tau / b1) * (b2 + temp);  // !!DeBuG!! Original code!!</span>
<a name="l01462"></a>01462     }
<a name="l01463"></a>01463     
<a name="l01464"></a>01464 }  <span class="comment">// [End subroutine GCOa]</span>
<a name="l01465"></a>01465 
</pre></div></div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jun 3 13:10:12 2010 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
